// This was generated by ChatGPT based on the original code and the following instruction:
// "help me write unit tests for this component:"
// Yes, it was asked to write for a component, but these are controllers.
// There were edits to fix issues.
import { createCategoryController, updateCategoryController, deleteCategoryController } from "./categoryController";
import categoryModel from "../models/categoryModel";

jest.mock("../models/categoryModel");
jest.mock("slugify", () => jest.fn((str) => str.toLowerCase().replace(/\s+/g, "-")));

describe("createCategoryController", () => {
  let req, res;

  beforeEach(() => {
    req = { body: {} };
    res = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn(),
    };
    jest.clearAllMocks();
  });

  test("should return 401 if name is missing", async () => {
    await createCategoryController(req, res);
    expect(res.status).toHaveBeenCalledWith(401);
    expect(res.send).toHaveBeenCalledWith({ message: "Name is required" });
  });

  test("should return 200 if category already exists", async () => {
    req.body.name = "Electronics";
    categoryModel.findOne.mockResolvedValue({ name: "Electronics" });

    await createCategoryController(req, res);

    expect(res.status).toHaveBeenCalledWith(200);
    expect(res.send).toHaveBeenCalledWith({
      success: true,
      message: "Category Already Exists",
    });
  });

  test("should create category and return 201", async () => {
    req.body.name = "Books";
    categoryModel.findOne.mockResolvedValue(null);

    const savedCategory = { _id: "123", name: "Books", slug: "books" };
    categoryModel.mockImplementation(() => ({
      save: jest.fn().mockResolvedValue(savedCategory),
    }));

    await createCategoryController(req, res);

    expect(res.status).toHaveBeenCalledWith(201);
    expect(res.send).toHaveBeenCalledWith({
      success: true,
      message: "New category created",
      category: savedCategory,
    });
  });

  test("should handle errors and return 500", async () => {
    req.body.name = "Toys";
    const returnedError = new Error("DB error");
    categoryModel.findOne.mockRejectedValue(returnedError);

    await createCategoryController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({
      success: false,
      error: returnedError,
      message: "Error in Category",
    });
  });
});

describe("updateCategoryController", () => {
  let req, res;

  beforeEach(() => {
    req = {
      body: { name: "New Category" },
      params: { id: "123" },
    };
    res = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn(),
    };
    jest.clearAllMocks();
  });

  it("should update a category successfully", async () => {
    const updatedCategory = { _id: "123", name: "New Category", slug: "new-category" };
    categoryModel.findByIdAndUpdate.mockResolvedValue(updatedCategory);

    await updateCategoryController(req, res);

    expect(categoryModel.findByIdAndUpdate).toHaveBeenCalledWith(
      "123",
      { name: "New Category", slug: "new-category" },
      { new: true }
    );
    expect(res.status).toHaveBeenCalledWith(200);
    expect(res.send).toHaveBeenCalledWith({
      success: true,
      messsage: "Category Updated Successfully",
      category: updatedCategory,
    });
  });

  it("should handle errors gracefully", async () => {
    const error = new Error("Database error");
    categoryModel.findByIdAndUpdate.mockRejectedValue(error);

    await updateCategoryController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({
      success: false,
      error,
      message: "Error while updating category",
    });
  });
});

describe("deleteCategoryController", () => {
  let req, res;

  beforeEach(() => {
    req = {
      params: { id: "123" },
    };
    res = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn(),
    };
    jest.clearAllMocks();
  });

  it("should delete a category successfully", async () => {
    categoryModel.findByIdAndDelete.mockResolvedValue({ _id: "123" });

    await deleteCategoryController(req, res);

    expect(categoryModel.findByIdAndDelete).toHaveBeenCalledWith("123");
    expect(res.status).toHaveBeenCalledWith(200);
    expect(res.send).toHaveBeenCalledWith({
      success: true,
      message: "Category Deleted Successfully",
    });
  });

  it("should handle errors gracefully", async () => {
    const error = new Error("DB delete failed");
    categoryModel.findByIdAndDelete.mockRejectedValue(error);

    await deleteCategoryController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({
      success: false,
      message: "Error while deleting category",
      error,
    });
  });
});
