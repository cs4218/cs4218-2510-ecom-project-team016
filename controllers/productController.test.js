// This was generated by ChatGPT based on the original code and the following instruction:
// "help me write unit tests for this component:"
// Yes, it was asked to write for a component, but these are controllers.
// There were edits to fix issues.
import path from "path";
import { createProductController, updateProductController, deleteProductController, getProductController, getSingleProductController, productPhotoController, productFiltersController, productCountController, productListController, searchProductController, realtedProductController } from "../controllers/productController.js";
import productModel from "../models/productModel";
import fs from "fs";
import slugify from "slugify";
import { da } from "date-fns/locale";

jest.mock("../models/productModel");
jest.mock("fs", () => ({
  readFileSync: jest.fn(),
}));
jest.mock("braintree");
jest.mock("slugify", () => jest.fn((str) => str.toLowerCase().replace(/\s+/g, "-")));

describe("createProductController", () => {
  let req, res;

  beforeEach(() => {
    req = {
      fields: {
        name: "Test Product",
        description: "Test Desc",
        price: 100,
        category: "123",
        quantity: 5,
        shipping: "1",
      },
      files: {},
    };

    res = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn(),
    };

    jest.clearAllMocks();
  });

  it("should reject if no name", async () => {
    req.fields.name = "";
    await createProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Name is Required" });
  });

  it("should reject if no description", async () => {
    req.fields.description = "";
    await createProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Description is Required" });
  });

  it("should reject if no price", async () => {
    req.fields.price = null;
    await createProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Price is Required" });
  });

  it("should reject if no category", async () => {
    req.fields.category = "";
    await createProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Category is Required" });
  });

  it("should reject if no quantity", async () => {
    req.fields.quantity = null;
    await createProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Quantity is Required" });
  });

  it("should reject if no shipping", async () => {
    req.fields.shipping = null;
    await createProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Shipping is Required" });
  });

  it("should return error if photo is too large", async () => {
    req.files.photo = { path: "/tmp/photo.jpg", type: "image/jpeg", size: 2000000 };
    await createProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({
      error: "photo is Required and should be less then 1mb",
    });
  });

  it("should create product successfully with eligible photo", async () => {
    req.files.photo = { path: "/tmp/photo.jpg", type: "image/jpeg", size: 500000 };
    fs.readFileSync.mockReturnValue(Buffer.from("fake"));
    await createProductController(req, res);

    expect(slugify).toHaveBeenCalledWith("Test Product");
    expect(productModel).toHaveBeenCalledWith(
      expect.objectContaining({ 
        name: "Test Product", 
        description: "Test Desc",
        price: 100,
        category: "123",
        quantity: 5,
        shipping: "1",
        slug: "test-product",
        photo: { data: expect.any(Buffer), contentType: "image/jpeg" }
      })
    );
    expect(productModel.prototype.save).toHaveBeenCalled();
    expect(res.status).toHaveBeenCalledWith(201);
    expect(res.send).toHaveBeenCalledWith(
      expect.objectContaining({ success: true, message: "Product Created Successfully" })
    );
  });

  it("should create product successfully without photo", async () => {
    await createProductController(req, res);

    expect(slugify).toHaveBeenCalledWith("Test Product");
    expect(productModel).toHaveBeenCalledWith(
      expect.objectContaining({ 
        name: "Test Product", 
        description: "Test Desc",
        price: 100,
        category: "123",
        quantity: 5,
        slug: "test-product" 
      })
    );
    expect(productModel.prototype.save).toHaveBeenCalled();
    expect(res.status).toHaveBeenCalledWith(201);
    expect(res.send).toHaveBeenCalledWith(
      expect.objectContaining({ success: true, message: "Product Created Successfully" })
    );
  });

  it("should handle save errors gracefully", async () => {
    productModel.mockImplementation(() => ({
      save: jest.fn().mockRejectedValue(new Error("DB error")),
    }));

    await createProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith(
      expect.objectContaining({ success: false, message: "Error in crearing product" })
    );
  });
});

describe("deleteProductController", () => {
  let req, res;

  beforeEach(() => {
    req = { params: { pid: "123" } };
    res = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn(),
    };
    jest.clearAllMocks();
  });

  it("should delete a product successfully", async () => {
    const selectMock = jest.fn().mockResolvedValue({ _id: "123" });
    productModel.findByIdAndDelete.mockReturnValue({ select: selectMock });

    await deleteProductController(req, res);

    expect(productModel.findByIdAndDelete).toHaveBeenCalledWith("123");
    expect(selectMock).toHaveBeenCalledWith("-photo");
    expect(res.status).toHaveBeenCalledWith(200);
    expect(res.send).toHaveBeenCalledWith({
      success: true,
      message: "Product Deleted Successfully",
    });
  });

  it("should handle errors gracefully", async () => {
    const error = new Error("DB error");
    const selectMock = jest.fn().mockRejectedValue(error);
    productModel.findByIdAndDelete.mockReturnValue({ select: selectMock });

    await deleteProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({
      success: false,
      message: "Error while deleting product",
      error,
    });
  });
});

describe("updateProductController", () => {
  let req, res, mockProduct;

  beforeEach(() => {
    mockProduct = {
      save: jest.fn().mockResolvedValue({ _id: "1" }),
      photo: {},
    };

    req = {
      params: { pid: "123" },
      fields: {
        name: "Test Product",
        description: "Test Desc",
        price: 100,
        category: "cat123",
        quantity: 5,
        shipping: "1",
      },
      files: {},
    };

    res = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn(),
    };

    productModel.findByIdAndUpdate.mockResolvedValue(mockProduct);
    jest.clearAllMocks();
  });

  it("should reject if no name", async () => {
    req.fields.name = "";
    await updateProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Name is Required" });
  });

  it("should reject if no description", async () => {
    req.fields.description = "";
    await updateProductController(req, res);
    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Description is Required" });
  });

  it("should reject if no price", async () => {
    req.fields.price = null;
    await updateProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Price is Required" });
  });

  it("should reject if no category", async () => {
    req.fields.category = "";
    await updateProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Category is Required" });
  });

  it("should reject if no quantity", async () => {
    req.fields.quantity = null;
    await updateProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Quantity is Required" });
  });

  it("should reject if no shipping", async () => {
    req.fields.shipping = null;
    await updateProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Shipping is Required" });
  });

  it("should return error if photo is too large", async () => {
    req.files.photo = { path: "/tmp/photo.jpg", type: "image/jpeg", size: 2000000 };

    await updateProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({
      error: "Photo is required and should be less then 1mb",
    });
  });

  it("should update a product successfully with photo", async () => {
    req.files.photo = { path: "/tmp/photo.jpg", type: "image/jpeg", size: 500000 };
    fs.readFileSync.mockReturnValue(Buffer.from("fake"));

    await updateProductController(req, res);

    expect(slugify).toHaveBeenCalledWith("Test Product");
    expect(productModel.findByIdAndUpdate).toHaveBeenCalledWith(
      "123",
      expect.objectContaining(
        {
          name: "Test Product",
          description: "Test Desc",
          price: 100,
          category: "cat123",
          quantity: 5,
          shipping: "1",
          slug: "test-product",
          photo: { data: expect.any(Buffer), contentType: "image/jpeg" }
        }
      ),
      { new: true }
    );
    expect(mockProduct.save).toHaveBeenCalled();
    expect(res.status).toHaveBeenCalledWith(201);
    expect(res.send).toHaveBeenCalledWith(
      expect.objectContaining({ success: true, message: "Product Updated Successfully" })
    );
  });

  it("should update a product successfully without photo", async () => {
    await updateProductController(req, res);

    expect(slugify).toHaveBeenCalledWith("Test Product");
    expect(productModel.findByIdAndUpdate).toHaveBeenCalledWith(
      "123",
      expect.objectContaining(
        {
          name: "Test Product",
          description: "Test Desc",
          price: 100,
          category: "cat123",
          quantity: 5,
          shipping: "1",
          slug: "test-product"
        }
      ),
      { new: true }
    );
    expect(mockProduct.save).toHaveBeenCalled();
    expect(res.status).toHaveBeenCalledWith(201);
    expect(res.send).toHaveBeenCalledWith(
      expect.objectContaining({ success: true, message: "Product Updated Successfully" })
    );
  });

  it("should handle database errors gracefully", async () => {
    productModel.findByIdAndUpdate.mockRejectedValue(new Error("DB error"));

    await updateProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith(
      expect.objectContaining({ success: false, message: "Error in Updating product" })
    );
  });
});

describe('getProductController', () => {
  let mockReq;
  let mockRes;
  let mockQuery;

  beforeEach(() => {
    jest.clearAllMocks();

    mockReq = {};

    mockRes = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn().mockReturnThis()
    };

    mockQuery = {
      populate: jest.fn().mockReturnThis(),
      select: jest.fn().mockReturnThis(),
      limit: jest.fn().mockReturnThis(),
      sort: jest.fn().mockResolvedValue([])
    };

    productModel.find = jest.fn().mockReturnValue(mockQuery);
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('Success Cases', () => {
    it('should return products with correct response format', async () => {
      const mockProducts = [
        { _id: '1', name: 'Product 1', category: { name: 'Category 1' } },
        { _id: '2', name: 'Product 2', category: { name: 'Category 2' } }
      ];

      mockQuery.sort.mockResolvedValue(mockProducts);

      await getProductController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({});
      expect(mockQuery.populate).toHaveBeenCalledWith('category');
      expect(mockQuery.select).toHaveBeenCalledWith('-photo');
      expect(mockQuery.limit).toHaveBeenCalledWith(12);
      expect(mockQuery.sort).toHaveBeenCalledWith({ createdAt: -1 });

      expect(mockRes.status).toHaveBeenCalledWith(200);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        countTotal: 2,
        message: 'All Products',
        products: mockProducts
      });
    });

    it('should handle empty product list', async () => {
      const mockProducts = [];
      mockQuery.sort.mockResolvedValue(mockProducts);

      await getProductController(mockReq, mockRes);

      expect(mockRes.status).toHaveBeenCalledWith(200);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        countTotal: 0,
        message: 'All Products',
        products: []
      });
    });

    it('should limit results to exactly 12 products', async () => {
      const mockProducts = Array.from({ length: 12 }, (_, i) => ({
        _id: `${i + 1}`,
        name: `Product ${i + 1}`,
        category: { name: `Category ${i + 1}` }
      }));

      mockQuery.sort.mockResolvedValue(mockProducts);

      await getProductController(mockReq, mockRes);

      expect(mockQuery.limit).toHaveBeenCalledWith(12);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        countTotal: 12,
        message: 'All Products',
        products: mockProducts
      });
    });
  });

  describe('Error Cases', () => {
    it('should handle database query errors', async () => {
      const mockError = new Error('Database connection failed');
      mockQuery.sort.mockRejectedValue(mockError);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await getProductController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalledWith(mockError);

      expect(mockRes.status).toHaveBeenCalledWith(500);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'Erorr in getting products',
        error: 'Database connection failed'
      });

      consoleSpy.mockRestore();
    });

    it('should handle populate method errors', async () => {
      const mockError = new Error('Population failed');
      mockQuery.populate.mockImplementation(() => {
        throw mockError;
      });

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await getProductController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalledWith(mockError);
      expect(mockRes.status).toHaveBeenCalledWith(500);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'Erorr in getting products',
        error: 'Population failed'
      });

      consoleSpy.mockRestore();
    });

    it('should handle errors without message property', async () => {
      const mockError = 'String error without message property';
      mockQuery.sort.mockRejectedValue(mockError);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await getProductController(mockReq, mockRes);

      expect(mockRes.status).toHaveBeenCalledWith(500);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'Erorr in getting products',
        error: undefined
      });

      consoleSpy.mockRestore();
    });
  });

  describe('Query Chain Validation', () => {
    it('should call query methods in correct order', async () => {
      const mockProducts = [{ _id: '1', name: 'Test Product' }];
      mockQuery.sort.mockResolvedValue(mockProducts);

      await getProductController(mockReq, mockRes);

      const findCall = productModel.find.mock.calls[0];
      const populateCall = mockQuery.populate.mock.calls[0];
      const selectCall = mockQuery.select.mock.calls[0];
      const limitCall = mockQuery.limit.mock.calls[0];
      const sortCall = mockQuery.sort.mock.calls[0];

      expect(findCall).toEqual([{}]);
      expect(populateCall).toEqual(['category']);
      expect(selectCall).toEqual(['-photo']);
      expect(limitCall).toEqual([12]);
      expect(sortCall).toEqual([{ createdAt: -1 }]);
    });

    it('should ensure all query methods are called exactly once', async () => {
      const mockProducts = [];
      mockQuery.sort.mockResolvedValue(mockProducts);

      await getProductController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledTimes(1);
      expect(mockQuery.populate).toHaveBeenCalledTimes(1);
      expect(mockQuery.select).toHaveBeenCalledTimes(1);
      expect(mockQuery.limit).toHaveBeenCalledTimes(1);
      expect(mockQuery.sort).toHaveBeenCalledTimes(1);
    });
  });
});

describe('getSingleProductController', () => {
  let mockReq;
  let mockRes;
  let mockQuery;

  beforeEach(() => {
    jest.clearAllMocks();

    mockReq = {
      params: {
        slug: 'test-product-slug'
      }
    };

    mockRes = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn().mockReturnThis()
    };

    mockQuery = {
      select: jest.fn().mockReturnThis(),
      populate: jest.fn().mockResolvedValue(null)
    };

    productModel.findOne = jest.fn().mockReturnValue(mockQuery);
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('Success Cases', () => {
    it('should return product when found by slug', async () => {
      const mockProduct = {
        _id: '1',
        name: 'Test Product',
        slug: 'test-product-slug',
        description: 'Test description',
        price: 99.99,
        category: {
          _id: 'cat1',
          name: 'Test Category'
        }
      };

      mockQuery.populate.mockResolvedValue(mockProduct);

      await getSingleProductController(mockReq, mockRes);

      expect(productModel.findOne).toHaveBeenCalledWith({ slug: 'test-product-slug' });
      expect(mockQuery.select).toHaveBeenCalledWith('-photo');
      expect(mockQuery.populate).toHaveBeenCalledWith('category');

      expect(mockRes.status).toHaveBeenCalledWith(200);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        message: 'Single Product Fetched',
        product: mockProduct
      });
    });

    it('should return null when product not found', async () => {
      mockQuery.populate.mockResolvedValue(null);

      await getSingleProductController(mockReq, mockRes);

      expect(productModel.findOne).toHaveBeenCalledWith({ slug: 'test-product-slug' });
      expect(mockRes.status).toHaveBeenCalledWith(200);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        message: 'Single Product Fetched',
        product: null
      });
    });

    it('should handle different slug values', async () => {
      mockReq.params.slug = 'another-product-123';
      const mockProduct = { _id: '2', name: 'Another Product', slug: 'another-product-123' };
      mockQuery.populate.mockResolvedValue(mockProduct);

      await getSingleProductController(mockReq, mockRes);

      expect(productModel.findOne).toHaveBeenCalledWith({ slug: 'another-product-123' });
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        message: 'Single Product Fetched',
        product: mockProduct
      });
    });

    it('should populate category field correctly', async () => {
      const mockProduct = {
        _id: '1',
        name: 'Test Product',
        category: {
          _id: 'cat1',
          name: 'Electronics',
          slug: 'electronics'
        }
      };
      mockQuery.populate.mockResolvedValue(mockProduct);

      await getSingleProductController(mockReq, mockRes);

      expect(mockQuery.populate).toHaveBeenCalledWith('category');
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        message: 'Single Product Fetched',
        product: mockProduct
      });
    });
  });

  describe('Error Cases', () => {
    it('should handle database query errors', async () => {
      const mockError = new Error('Database connection failed');
      mockQuery.populate.mockRejectedValue(mockError);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await getSingleProductController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalledWith(mockError);

      expect(mockRes.status).toHaveBeenCalledWith(500);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'Eror while getitng single product',
        error: mockError
      });

      consoleSpy.mockRestore();
    });

    it('should handle findOne method errors', async () => {
      const mockError = new Error('Invalid slug format');
      productModel.findOne.mockImplementation(() => {
        throw mockError;
      });

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await getSingleProductController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalledWith(mockError);
      expect(mockRes.status).toHaveBeenCalledWith(500);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'Eror while getitng single product',
        error: mockError
      });

      consoleSpy.mockRestore();
    });

    it('should handle populate method errors', async () => {
      const mockError = new Error('Population failed for category');
      mockQuery.populate.mockRejectedValue(mockError);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await getSingleProductController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalledWith(mockError);
      expect(mockRes.status).toHaveBeenCalledWith(500);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'Eror while getitng single product',
        error: mockError
      });

      consoleSpy.mockRestore();
    });

    it('should handle missing slug parameter', async () => {
      mockReq.params.slug = undefined;
      mockQuery.populate.mockResolvedValue(null);

      await getSingleProductController(mockReq, mockRes);

      expect(productModel.findOne).toHaveBeenCalledWith({ slug: undefined });
      expect(mockRes.status).toHaveBeenCalledWith(200);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        message: 'Single Product Fetched',
        product: null
      });
    });
  });

  describe('Query Chain Validation', () => {
    it('should call query methods in correct order', async () => {
      const mockProduct = { _id: '1', name: 'Test Product' };
      mockQuery.populate.mockResolvedValue(mockProduct);

      await getSingleProductController(mockReq, mockRes);

      const findOneCall = productModel.findOne.mock.calls[0];
      const selectCall = mockQuery.select.mock.calls[0];
      const populateCall = mockQuery.populate.mock.calls[0];

      expect(findOneCall).toEqual([{ slug: 'test-product-slug' }]);
      expect(selectCall).toEqual(['-photo']);
      expect(populateCall).toEqual(['category']);
    });

    it('should ensure all query methods are called exactly once', async () => {
      mockQuery.populate.mockResolvedValue(null);

      await getSingleProductController(mockReq, mockRes);

      expect(productModel.findOne).toHaveBeenCalledTimes(1);
      expect(mockQuery.select).toHaveBeenCalledTimes(1);
      expect(mockQuery.populate).toHaveBeenCalledTimes(1);
    });

    it('should exclude photo field from selection', async () => {
      mockQuery.populate.mockResolvedValue({ _id: '1', name: 'Test' });

      await getSingleProductController(mockReq, mockRes);

      expect(mockQuery.select).toHaveBeenCalledWith('-photo');
    });
  });

  describe('Request Parameter Handling', () => {
    it('should handle special characters in slug', async () => {
      mockReq.params.slug = 'product-with-special-chars-&-symbols';
      mockQuery.populate.mockResolvedValue(null);

      await getSingleProductController(mockReq, mockRes);

      expect(productModel.findOne).toHaveBeenCalledWith({ 
        slug: 'product-with-special-chars-&-symbols' 
      });
    });

    it('should handle empty string slug', async () => {
      mockReq.params.slug = '';
      mockQuery.populate.mockResolvedValue(null);

      await getSingleProductController(mockReq, mockRes);

      expect(productModel.findOne).toHaveBeenCalledWith({ slug: '' });
    });

    it('should handle numeric slug values', async () => {
      mockReq.params.slug = '12345';
      mockQuery.populate.mockResolvedValue(null);

      await getSingleProductController(mockReq, mockRes);

      expect(productModel.findOne).toHaveBeenCalledWith({ slug: '12345' });
    });
  });
});

describe('productPhotoController', () => {
  let mockReq;
  let mockRes;
  let mockQuery;

  beforeEach(() => {
    jest.clearAllMocks();

    mockReq = {
      params: {
        pid: '507f1f77bcf86cd799439011'
      }
    };

    mockRes = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn().mockReturnThis(),
      set: jest.fn().mockReturnThis()
    };

    mockQuery = {
      select: jest.fn().mockResolvedValue(null)
    };

    productModel.findById = jest.fn().mockReturnValue(mockQuery);
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('Success Cases', () => {
    it('should return photo data with correct content type', async () => {
      const mockProduct = {
        _id: '507f1f77bcf86cd799439011',
        photo: {
          data: Buffer.from('fake-image-data'),
          contentType: 'image/jpeg'
        }
      };

      mockQuery.select.mockResolvedValue(mockProduct);

      await productPhotoController(mockReq, mockRes);

      expect(productModel.findById).toHaveBeenCalledWith('507f1f77bcf86cd799439011');
      expect(mockQuery.select).toHaveBeenCalledWith('photo');
      expect(mockRes.set).toHaveBeenCalledWith('Content-type', 'image/jpeg');
      expect(mockRes.status).toHaveBeenCalledWith(200);
      expect(mockRes.send).toHaveBeenCalledWith(Buffer.from('fake-image-data'));
    });

    it('should handle different image types', async () => {
      const mockProduct = {
        _id: '507f1f77bcf86cd799439011',
        photo: {
          data: Buffer.from('png-image-data'),
          contentType: 'image/png'
        }
      };

      mockQuery.select.mockResolvedValue(mockProduct);

      await productPhotoController(mockReq, mockRes);

      expect(mockRes.set).toHaveBeenCalledWith('Content-type', 'image/png');
      expect(mockRes.status).toHaveBeenCalledWith(200);
      expect(mockRes.send).toHaveBeenCalledWith(Buffer.from('png-image-data'));
    });

    it('should handle large photo data', async () => {
      const largeBuffer = Buffer.alloc(1000000, 'x');
      const mockProduct = {
        _id: '507f1f77bcf86cd799439011',
        photo: {
          data: largeBuffer,
          contentType: 'image/jpeg'
        }
      };

      mockQuery.select.mockResolvedValue(mockProduct);

      await productPhotoController(mockReq, mockRes);

      expect(mockRes.send).toHaveBeenCalledWith(largeBuffer);
    });
  });

  describe('No Photo Data Cases', () => {
    it('should not respond when product has no photo data', async () => {
      const mockProduct = {
        _id: '507f1f77bcf86cd799439011',
        photo: {
          data: null,
          contentType: 'image/jpeg'
        }
      };

      mockQuery.select.mockResolvedValue(mockProduct);

      await productPhotoController(mockReq, mockRes);

      expect(mockRes.set).not.toHaveBeenCalled();
      expect(mockRes.status).not.toHaveBeenCalled();
      expect(mockRes.send).not.toHaveBeenCalled();
    });

    it('should not respond when product has empty photo data', async () => {
      const mockProduct = {
        _id: '507f1f77bcf86cd799439011',
        photo: {
          data: '',
          contentType: 'image/jpeg'
        }
      };

      mockQuery.select.mockResolvedValue(mockProduct);

      await productPhotoController(mockReq, mockRes);

      expect(mockRes.set).not.toHaveBeenCalled();
      expect(mockRes.status).not.toHaveBeenCalled();
      expect(mockRes.send).not.toHaveBeenCalled();
    });

    it('should not respond when product has undefined photo data', async () => {
      const mockProduct = {
        _id: '507f1f77bcf86cd799439011',
        photo: {
          data: undefined,
          contentType: 'image/jpeg'
        }
      };

      mockQuery.select.mockResolvedValue(mockProduct);

      await productPhotoController(mockReq, mockRes);

      expect(mockRes.set).not.toHaveBeenCalled();
      expect(mockRes.status).not.toHaveBeenCalled();
      expect(mockRes.send).not.toHaveBeenCalled();
    });
  });

  describe('Error Cases', () => {
    it('should handle database query errors', async () => {
      const mockError = new Error('Database connection failed');
      mockQuery.select.mockRejectedValue(mockError);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await productPhotoController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalledWith(mockError);
      expect(mockRes.status).toHaveBeenCalledWith(500);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'Erorr while getting photo',
        error: mockError
      });

      consoleSpy.mockRestore();
    });

    it('should handle invalid product ID', async () => {
      const mockError = new Error('Invalid ObjectId');
      mockQuery.select.mockRejectedValue(mockError);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await productPhotoController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalledWith(mockError);
      expect(mockRes.status).toHaveBeenCalledWith(500);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'Erorr while getting photo',
        error: mockError
      });

      consoleSpy.mockRestore();
    });

    it('should handle product not found', async () => {
      mockQuery.select.mockResolvedValue(null);
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();
    
      await productPhotoController(mockReq, mockRes);
    
      expect(productModel.findById).toHaveBeenCalledWith('507f1f77bcf86cd799439011');
      expect(consoleSpy).toHaveBeenCalled();
      expect(mockRes.status).toHaveBeenCalledWith(500);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'Erorr while getting photo',
        error: expect.any(TypeError)
      });
    
      consoleSpy.mockRestore();
    });

    it('should handle product without photo field', async () => {
      const mockProduct = {
        _id: '507f1f77bcf86cd799439011',
        name: 'Product without photo'
      };

      mockQuery.select.mockResolvedValue(mockProduct);
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await productPhotoController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalled();
      expect(mockRes.status).toHaveBeenCalledWith(500);

      consoleSpy.mockRestore();
    });
  });

  describe('Request Parameter Handling', () => {
    it('should handle different product ID formats', async () => {
      mockReq.params.pid = '507f1f77bcf86cd799439012';
      const mockProduct = {
        photo: {
          data: Buffer.from('test'),
          contentType: 'image/gif'
        }
      };

      mockQuery.select.mockResolvedValue(mockProduct);

      await productPhotoController(mockReq, mockRes);

      expect(productModel.findById).toHaveBeenCalledWith('507f1f77bcf86cd799439012');
    });

    it('should handle missing product ID', async () => {
      mockReq.params.pid = undefined;
      const mockError = new Error('Product ID is required');
      mockQuery.select.mockRejectedValue(mockError);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await productPhotoController(mockReq, mockRes);

      expect(productModel.findById).toHaveBeenCalledWith(undefined);
      expect(mockRes.status).toHaveBeenCalledWith(500);

      consoleSpy.mockRestore();
    });
  });

  describe('Query Validation', () => {
    it('should call findById with correct parameters', async () => {
      mockQuery.select.mockResolvedValue(null);

      await productPhotoController(mockReq, mockRes);

      expect(productModel.findById).toHaveBeenCalledWith('507f1f77bcf86cd799439011');
      expect(productModel.findById).toHaveBeenCalledTimes(1);
    });

    it('should select only photo field', async () => {
      mockQuery.select.mockResolvedValue(null);

      await productPhotoController(mockReq, mockRes);

      expect(mockQuery.select).toHaveBeenCalledWith('photo');
      expect(mockQuery.select).toHaveBeenCalledTimes(1);
    });
  });
});

describe('productFiltersController', () => {
  let mockReq;
  let mockRes;

  beforeEach(() => {
    jest.clearAllMocks();

    mockReq = {
      body: {
        checked: [],
        radio: []
      }
    };

    mockRes = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn().mockReturnThis()
    };

    productModel.find = jest.fn().mockResolvedValue([]);
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('Success Cases', () => {
    it('should return all products when no filters applied', async () => {
      const mockProducts = [
        { _id: '1', name: 'Product 1', price: 100 },
        { _id: '2', name: 'Product 2', price: 200 }
      ];

      productModel.find.mockResolvedValue(mockProducts);

      await productFiltersController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({});
      expect(mockRes.status).toHaveBeenCalledWith(200);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        products: mockProducts
      });
    });

    it('should filter by category only', async () => {
      mockReq.body.checked = ['cat1', 'cat2'];
      const mockProducts = [
        { _id: '1', name: 'Product 1', category: 'cat1' }
      ];

      productModel.find.mockResolvedValue(mockProducts);

      await productFiltersController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        category: ['cat1', 'cat2']
      });
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        products: mockProducts
      });
    });

    it('should filter by price range only', async () => {
      mockReq.body.radio = [50, 200];
      const mockProducts = [
        { _id: '1', name: 'Product 1', price: 100 }
      ];

      productModel.find.mockResolvedValue(mockProducts);

      await productFiltersController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        price: { $gte: 50, $lte: 200 }
      });
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        products: mockProducts
      });
    });

    it('should filter by both category and price range', async () => {
      mockReq.body.checked = ['electronics'];
      mockReq.body.radio = [100, 500];
      const mockProducts = [
        { _id: '1', name: 'Laptop', category: 'electronics', price: 300 }
      ];

      productModel.find.mockResolvedValue(mockProducts);

      await productFiltersController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        category: ['electronics'],
        price: { $gte: 100, $lte: 500 }
      });
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        products: mockProducts
      });
    });

    it('should return empty array when no products match filters', async () => {
      mockReq.body.checked = ['nonexistent'];
      productModel.find.mockResolvedValue([]);

      await productFiltersController(mockReq, mockRes);

      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        products: []
      });
    });

    it('should handle single category filter', async () => {
      mockReq.body.checked = ['books'];
      const mockProducts = [{ _id: '1', name: 'Book 1', category: 'books' }];

      productModel.find.mockResolvedValue(mockProducts);

      await productFiltersController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        category: ['books']
      });
    });

    it('should handle zero price range', async () => {
      mockReq.body.radio = [0, 50];
      const mockProducts = [{ _id: '1', name: 'Free Product', price: 0 }];

      productModel.find.mockResolvedValue(mockProducts);

      await productFiltersController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        price: { $gte: 0, $lte: 50 }
      });
    });
  });

  describe('Edge Cases', () => {
    it('should ignore empty checked array', async () => {
      mockReq.body.checked = [];
      mockReq.body.radio = [10, 20];

      productModel.find.mockResolvedValue([]);

      await productFiltersController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        price: { $gte: 10, $lte: 20 }
      });
    });

    it('should ignore empty radio array', async () => {
      mockReq.body.checked = ['category1'];
      mockReq.body.radio = [];

      productModel.find.mockResolvedValue([]);

      await productFiltersController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        category: ['category1']
      });
    });

    it('should handle single element arrays', async () => {
      mockReq.body.checked = ['single-category'];
      mockReq.body.radio = [100];

      productModel.find.mockResolvedValue([]);

      await productFiltersController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        category: ['single-category'],
        price: { $gte: 100, $lte: undefined }
      });
    });

    it('should handle negative price values', async () => {
      mockReq.body.radio = [-10, 100];

      productModel.find.mockResolvedValue([]);

      await productFiltersController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        price: { $gte: -10, $lte: 100 }
      });
    });
  });

  describe('Error Cases', () => {
    it('should handle database query errors', async () => {
      const mockError = new Error('Database connection failed');
      productModel.find.mockRejectedValue(mockError);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await productFiltersController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalledWith(mockError);
      expect(mockRes.status).toHaveBeenCalledWith(400);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'Error WHile Filtering Products',
        error: mockError
      });

      consoleSpy.mockRestore();
    });

    it('should handle missing request body properties', async () => {
      mockReq.body = {};
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await productFiltersController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalled();
      expect(mockRes.status).toHaveBeenCalledWith(400);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'Error WHile Filtering Products',
        error: expect.any(TypeError)
      });

      consoleSpy.mockRestore();
    });

    it('should handle null request body', async () => {
      mockReq.body = null;
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await productFiltersController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalled();
      expect(mockRes.status).toHaveBeenCalledWith(400);

      consoleSpy.mockRestore();
    });

    it('should handle invalid filter arguments without error', async () => {
      mockReq.body.checked = 'invalid-string';
      mockReq.body.radio = 'invalid-string';
    
      productModel.find.mockResolvedValue([]);
    
      await productFiltersController(mockReq, mockRes);
    
      // Strings have length > 0, so they get processed
      // checked = 'invalid-string', radio[0] = 'i', radio[1] = 'n'
      expect(productModel.find).toHaveBeenCalledWith({
        category: 'invalid-string',
        price: { $gte: 'i', $lte: 'n' }
      });
    
      expect(mockRes.status).toHaveBeenCalledWith(200);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        products: []
      });
    });    
  });

  describe('Filter Logic Validation', () => {
    it('should not add category filter when checked array length is 0', async () => {
      mockReq.body.checked = [];
      mockReq.body.radio = [];

      productModel.find.mockResolvedValue([]);

      await productFiltersController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({});
    });

    it('should not add price filter when radio array length is 0', async () => {
      mockReq.body.checked = ['cat1'];
      mockReq.body.radio = [];

      productModel.find.mockResolvedValue([]);

      await productFiltersController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        category: ['cat1']
      });
    });

    it('should build correct MongoDB query structure', async () => {
      mockReq.body.checked = ['electronics', 'books'];
      mockReq.body.radio = [25, 75];

      productModel.find.mockResolvedValue([]);

      await productFiltersController(mockReq, mockRes);

      const expectedQuery = {
        category: ['electronics', 'books'],
        price: { $gte: 25, $lte: 75 }
      };

      expect(productModel.find).toHaveBeenCalledWith(expectedQuery);
    });
  });
});

describe('productCountController', () => {
  let mockReq;
  let mockRes;
  let mockQuery;

  beforeEach(() => {
    jest.clearAllMocks();

    mockReq = {};

    mockRes = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn().mockReturnThis()
    };

    mockQuery = {
      estimatedDocumentCount: jest.fn().mockResolvedValue(0)
    };

    productModel.find = jest.fn().mockReturnValue(mockQuery);
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('Success Cases', () => {
    it('should return total product count', async () => {
      const mockTotal = 25;
      mockQuery.estimatedDocumentCount.mockResolvedValue(mockTotal);

      await productCountController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({});
      expect(mockQuery.estimatedDocumentCount).toHaveBeenCalledTimes(1);
      expect(mockRes.status).toHaveBeenCalledWith(200);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        total: 25
      });
    });

    it('should handle zero product count', async () => {
      mockQuery.estimatedDocumentCount.mockResolvedValue(0);

      await productCountController(mockReq, mockRes);

      expect(mockRes.status).toHaveBeenCalledWith(200);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        total: 0
      });
    });

    it('should handle large product count', async () => {
      const largeCount = 999999;
      mockQuery.estimatedDocumentCount.mockResolvedValue(largeCount);

      await productCountController(mockReq, mockRes);

      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        total: 999999
      });
    });

    it('should handle single product count', async () => {
      mockQuery.estimatedDocumentCount.mockResolvedValue(1);

      await productCountController(mockReq, mockRes);

      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        total: 1
      });
    });
  });

  describe('Error Cases', () => {
    it('should handle database connection errors', async () => {
      const mockError = new Error('Database connection failed');
      mockQuery.estimatedDocumentCount.mockRejectedValue(mockError);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await productCountController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalledWith(mockError);
      expect(mockRes.status).toHaveBeenCalledWith(400);
      expect(mockRes.send).toHaveBeenCalledWith({
        message: 'Error in product count',
        error: mockError,
        success: false
      });

      consoleSpy.mockRestore();
    });

    it('should handle estimatedDocumentCount method errors', async () => {
      const mockError = new Error('Count operation failed');
      mockQuery.estimatedDocumentCount.mockRejectedValue(mockError);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await productCountController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalledWith(mockError);
      expect(mockRes.status).toHaveBeenCalledWith(400);
      expect(mockRes.send).toHaveBeenCalledWith({
        message: 'Error in product count',
        error: mockError,
        success: false
      });

      consoleSpy.mockRestore();
    });

    it('should handle find method errors', async () => {
      const mockError = new Error('Find operation failed');
      productModel.find.mockImplementation(() => {
        throw mockError;
      });

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await productCountController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalledWith(mockError);
      expect(mockRes.status).toHaveBeenCalledWith(400);
      expect(mockRes.send).toHaveBeenCalledWith({
        message: 'Error in product count',
        error: mockError,
        success: false
      });

      consoleSpy.mockRestore();
    });

    it('should handle timeout errors', async () => {
      const mockError = new Error('Operation timed out');
      mockQuery.estimatedDocumentCount.mockRejectedValue(mockError);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await productCountController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalledWith(mockError);
      expect(mockRes.status).toHaveBeenCalledWith(400);

      consoleSpy.mockRestore();
    });
  });

  describe('Query Validation', () => {
    it('should call find with empty object', async () => {
      mockQuery.estimatedDocumentCount.mockResolvedValue(10);

      await productCountController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({});
      expect(productModel.find).toHaveBeenCalledTimes(1);
    });

    it('should call estimatedDocumentCount exactly once', async () => {
      mockQuery.estimatedDocumentCount.mockResolvedValue(5);

      await productCountController(mockReq, mockRes);

      expect(mockQuery.estimatedDocumentCount).toHaveBeenCalledTimes(1);
      expect(mockQuery.estimatedDocumentCount).toHaveBeenCalledWith();
    });
  });

  describe('Response Structure Validation', () => {
    it('should return exact response structure on success', async () => {
      mockQuery.estimatedDocumentCount.mockResolvedValue(42);

      await productCountController(mockReq, mockRes);

      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        total: 42
      });
    });

    it('should return exact error response structure', async () => {
      const mockError = new Error('Test error');
      mockQuery.estimatedDocumentCount.mockRejectedValue(mockError);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await productCountController(mockReq, mockRes);

      expect(mockRes.send).toHaveBeenCalledWith({
        message: 'Error in product count',
        error: mockError,
        success: false
      });

      consoleSpy.mockRestore();
    });

    it('should not include extra properties in response', async () => {
      mockQuery.estimatedDocumentCount.mockResolvedValue(15);

      await productCountController(mockReq, mockRes);

      const responseCall = mockRes.send.mock.calls[0][0];
      const keys = Object.keys(responseCall);

      expect(keys).toEqual(['success', 'total']);
      expect(keys).toHaveLength(2);
    });
  });
});

describe('productListController', () => {
  let mockReq;
  let mockRes;
  let mockQuery;

  beforeEach(() => {
    jest.clearAllMocks();

    mockReq = {
      params: {}
    };

    mockRes = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn().mockReturnThis()
    };

    mockQuery = {
      select: jest.fn().mockReturnThis(),
      skip: jest.fn().mockReturnThis(),
      limit: jest.fn().mockReturnThis(),
      sort: jest.fn().mockResolvedValue([])
    };

    productModel.find = jest.fn().mockReturnValue(mockQuery);
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('Success Cases', () => {
    it('should return first page products by default', async () => {
      const mockProducts = [
        { _id: '1', name: 'Product 1', createdAt: new Date() },
        { _id: '2', name: 'Product 2', createdAt: new Date() }
      ];

      mockQuery.sort.mockResolvedValue(mockProducts);

      await productListController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({});
      expect(mockQuery.select).toHaveBeenCalledWith('-photo');
      expect(mockQuery.skip).toHaveBeenCalledWith(0);
      expect(mockQuery.limit).toHaveBeenCalledWith(6);
      expect(mockQuery.sort).toHaveBeenCalledWith({ createdAt: -1 });

      expect(mockRes.status).toHaveBeenCalledWith(200);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        products: mockProducts
      });
    });

    it('should return correct page when page parameter provided', async () => {
      mockReq.params.page = '3';
      const mockProducts = [{ _id: '1', name: 'Product 1' }];

      mockQuery.sort.mockResolvedValue(mockProducts);

      await productListController(mockReq, mockRes);

      expect(mockQuery.skip).toHaveBeenCalledWith(12); // (3-1) * 6 = 12
      expect(mockQuery.limit).toHaveBeenCalledWith(6);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        products: mockProducts
      });
    });

    it('should handle second page correctly', async () => {
      mockReq.params.page = '2';
      const mockProducts = [];

      mockQuery.sort.mockResolvedValue(mockProducts);

      await productListController(mockReq, mockRes);

      expect(mockQuery.skip).toHaveBeenCalledWith(6); // (2-1) * 6 = 6
      expect(mockQuery.limit).toHaveBeenCalledWith(6);
    });

    it('should handle page 1 explicitly', async () => {
      mockReq.params.page = '1';
      const mockProducts = [];

      mockQuery.sort.mockResolvedValue(mockProducts);

      await productListController(mockReq, mockRes);

      expect(mockQuery.skip).toHaveBeenCalledWith(0); // (1-1) * 6 = 0
    });

    it('should return empty array when no products found', async () => {
      mockReq.params.page = '10';
      mockQuery.sort.mockResolvedValue([]);

      await productListController(mockReq, mockRes);

      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        products: []
      });
    });

    it('should limit to exactly 6 products per page', async () => {
      const mockProducts = Array.from({ length: 6 }, (_, i) => ({
        _id: `${i + 1}`,
        name: `Product ${i + 1}`
      }));

      mockQuery.sort.mockResolvedValue(mockProducts);

      await productListController(mockReq, mockRes);

      expect(mockQuery.limit).toHaveBeenCalledWith(6);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        products: mockProducts
      });
    });
  });

  describe('Edge Cases', () => {
    it('should handle page 0 as valid input', async () => {
      mockReq.params.page = '0';
      mockQuery.sort.mockResolvedValue([]);

      await productListController(mockReq, mockRes);

      expect(mockQuery.skip).toHaveBeenCalledWith(-6); // (0-1) * 6 = -6
    });

    it('should handle negative page numbers', async () => {
      mockReq.params.page = '-1';
      mockQuery.sort.mockResolvedValue([]);

      await productListController(mockReq, mockRes);

      expect(mockQuery.skip).toHaveBeenCalledWith(-12); // (-1-1) * 6 = -12
    });

    it('should handle string page numbers', async () => {
      mockReq.params.page = 'abc';
      mockQuery.sort.mockResolvedValue([]);

      await productListController(mockReq, mockRes);

      expect(mockQuery.skip).toHaveBeenCalledWith(NaN); // ('abc'-1) * 6 = NaN
    });

    it('should handle undefined page parameter', async () => {
      mockReq.params.page = undefined;
      mockQuery.sort.mockResolvedValue([]);

      await productListController(mockReq, mockRes);

      expect(mockQuery.skip).toHaveBeenCalledWith(0); // default page 1: (1-1) * 6 = 0
    });

    it('should handle null page parameter', async () => {
      mockReq.params.page = null;
      mockQuery.sort.mockResolvedValue([]);

      await productListController(mockReq, mockRes);

      expect(mockQuery.skip).toHaveBeenCalledWith(0); // null is falsy, defaults to page 1
    });

    it('should handle empty string page parameter', async () => {
      mockReq.params.page = '';
      mockQuery.sort.mockResolvedValue([]);

      await productListController(mockReq, mockRes);

      expect(mockQuery.skip).toHaveBeenCalledWith(0); // empty string is falsy, defaults to page 1
    });

    it('should handle decimal page numbers', async () => {
      mockReq.params.page = '2.5';
      mockQuery.sort.mockResolvedValue([]);

      await productListController(mockReq, mockRes);

      expect(mockQuery.skip).toHaveBeenCalledWith(9); // (2.5-1) * 6 = 9
    });
  });

  describe('Error Cases', () => {
    it('should handle database query errors', async () => {
      const mockError = new Error('Database connection failed');
      mockQuery.sort.mockRejectedValue(mockError);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await productListController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalledWith(mockError);
      expect(mockRes.status).toHaveBeenCalledWith(400);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'error in per page ctrl',
        error: mockError
      });

      consoleSpy.mockRestore();
    });

    it('should handle find method errors', async () => {
      const mockError = new Error('Find operation failed');
      productModel.find.mockImplementation(() => {
        throw mockError;
      });

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await productListController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalledWith(mockError);
      expect(mockRes.status).toHaveBeenCalledWith(400);

      consoleSpy.mockRestore();
    });

    it('should handle sort method errors', async () => {
      const mockError = new Error('Sort operation failed');
      mockQuery.sort.mockRejectedValue(mockError);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await productListController(mockReq, mockRes);

      expect(mockRes.status).toHaveBeenCalledWith(400);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'error in per page ctrl',
        error: mockError
      });

      consoleSpy.mockRestore();
    });
  });

  describe('Query Chain Validation', () => {
    it('should call query methods in correct order', async () => {
      mockReq.params.page = '2';
      mockQuery.sort.mockResolvedValue([]);

      await productListController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({});
      expect(mockQuery.select).toHaveBeenCalledWith('-photo');
      expect(mockQuery.skip).toHaveBeenCalledWith(6);
      expect(mockQuery.limit).toHaveBeenCalledWith(6);
      expect(mockQuery.sort).toHaveBeenCalledWith({ createdAt: -1 });
    });

    it('should call each query method exactly once', async () => {
      mockQuery.sort.mockResolvedValue([]);

      await productListController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledTimes(1);
      expect(mockQuery.select).toHaveBeenCalledTimes(1);
      expect(mockQuery.skip).toHaveBeenCalledTimes(1);
      expect(mockQuery.limit).toHaveBeenCalledTimes(1);
      expect(mockQuery.sort).toHaveBeenCalledTimes(1);
    });

    it('should exclude photo field from selection', async () => {
      mockQuery.sort.mockResolvedValue([]);

      await productListController(mockReq, mockRes);

      expect(mockQuery.select).toHaveBeenCalledWith('-photo');
    });

    it('should sort by createdAt in descending order', async () => {
      mockQuery.sort.mockResolvedValue([]);

      await productListController(mockReq, mockRes);

      expect(mockQuery.sort).toHaveBeenCalledWith({ createdAt: -1 });
    });
  });

  describe('Pagination Logic Validation', () => {
    it('should calculate skip correctly for various pages', async () => {
      const testCases = [
        { page: '1', expectedSkip: 0 },
        { page: '2', expectedSkip: 6 },
        { page: '3', expectedSkip: 12 },
        { page: '5', expectedSkip: 24 },
        { page: '10', expectedSkip: 54 }
      ];

      for (const testCase of testCases) {
        jest.clearAllMocks();
        mockReq.params.page = testCase.page;
        mockQuery.sort.mockResolvedValue([]);

        await productListController(mockReq, mockRes);

        expect(mockQuery.skip).toHaveBeenCalledWith(testCase.expectedSkip);
      }
    });

    it('should always use perPage value of 6', async () => {
      const pages = ['1', '2', '3', '10'];

      for (const page of pages) {
        jest.clearAllMocks();
        mockReq.params.page = page;
        mockQuery.sort.mockResolvedValue([]);

        await productListController(mockReq, mockRes);

        expect(mockQuery.limit).toHaveBeenCalledWith(6);
      }
    });
  });
});

describe('searchProductController', () => {
  let mockReq;
  let mockRes;
  let mockQuery;

  beforeEach(() => {
    jest.clearAllMocks();

    mockReq = {
      params: {
        keyword: 'test'
      }
    };

    mockRes = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn().mockReturnThis(),
      json: jest.fn().mockReturnThis()
    };

    mockQuery = {
      select: jest.fn().mockResolvedValue([])
    };

    productModel.find = jest.fn().mockReturnValue(mockQuery);
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('Success Cases', () => {
    it('should search products by keyword in name and description', async () => {
      const mockProducts = [
        { _id: '1', name: 'Test Product', description: 'A test item' },
        { _id: '2', name: 'Another Item', description: 'Contains test keyword' }
      ];

      mockQuery.select.mockResolvedValue(mockProducts);

      await searchProductController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        $or: [
          { name: { $regex: 'test', $options: 'i' } },
          { description: { $regex: 'test', $options: 'i' } }
        ]
      });
      expect(mockQuery.select).toHaveBeenCalledWith('-photo');
      expect(mockRes.json).toHaveBeenCalledWith(mockProducts);
    });

    it('should handle case insensitive search', async () => {
      mockReq.params.keyword = 'LAPTOP';
      const mockProducts = [
        { _id: '1', name: 'laptop computer', description: 'Gaming laptop' }
      ];

      mockQuery.select.mockResolvedValue(mockProducts);

      await searchProductController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        $or: [
          { name: { $regex: 'LAPTOP', $options: 'i' } },
          { description: { $regex: 'LAPTOP', $options: 'i' } }
        ]
      });
      expect(mockRes.json).toHaveBeenCalledWith(mockProducts);
    });

    it('should return empty array when no products match', async () => {
      mockReq.params.keyword = 'nonexistent';
      mockQuery.select.mockResolvedValue([]);

      await searchProductController(mockReq, mockRes);

      expect(mockRes.json).toHaveBeenCalledWith([]);
    });

    it('should handle single character search', async () => {
      mockReq.params.keyword = 'a';
      const mockProducts = [
        { _id: '1', name: 'Apple', description: 'Fruit' }
      ];

      mockQuery.select.mockResolvedValue(mockProducts);

      await searchProductController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        $or: [
          { name: { $regex: 'a', $options: 'i' } },
          { description: { $regex: 'a', $options: 'i' } }
        ]
      });
    });

    it('should handle multi-word search terms', async () => {
      mockReq.params.keyword = 'gaming laptop';
      const mockProducts = [
        { _id: '1', name: 'Gaming Laptop Pro', description: 'High-end gaming laptop' }
      ];

      mockQuery.select.mockResolvedValue(mockProducts);

      await searchProductController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        $or: [
          { name: { $regex: 'gaming laptop', $options: 'i' } },
          { description: { $regex: 'gaming laptop', $options: 'i' } }
        ]
      });
    });

    it('should exclude photo field from results', async () => {
      mockQuery.select.mockResolvedValue([]);

      await searchProductController(mockReq, mockRes);

      expect(mockQuery.select).toHaveBeenCalledWith('-photo');
    });
  });

  describe('Edge Cases', () => {
    it('should handle empty keyword', async () => {
      mockReq.params.keyword = '';
      mockQuery.select.mockResolvedValue([]);

      await searchProductController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        $or: [
          { name: { $regex: '', $options: 'i' } },
          { description: { $regex: '', $options: 'i' } }
        ]
      });
    });

    it('should handle special characters in keyword', async () => {
      mockReq.params.keyword = '$100 deal!';
      mockQuery.select.mockResolvedValue([]);

      await searchProductController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        $or: [
          { name: { $regex: '$100 deal!', $options: 'i' } },
          { description: { $regex: '$100 deal!', $options: 'i' } }
        ]
      });
    });

    it('should handle regex special characters', async () => {
      mockReq.params.keyword = 'product.*test';
      mockQuery.select.mockResolvedValue([]);

      await searchProductController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        $or: [
          { name: { $regex: 'product.*test', $options: 'i' } },
          { description: { $regex: 'product.*test', $options: 'i' } }
        ]
      });
    });

    it('should handle numeric keywords', async () => {
      mockReq.params.keyword = '2023';
      mockQuery.select.mockResolvedValue([]);

      await searchProductController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        $or: [
          { name: { $regex: '2023', $options: 'i' } },
          { description: { $regex: '2023', $options: 'i' } }
        ]
      });
    });

    it('should handle undefined keyword', async () => {
      mockReq.params.keyword = undefined;
      mockQuery.select.mockResolvedValue([]);

      await searchProductController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        $or: [
          { name: { $regex: undefined, $options: 'i' } },
          { description: { $regex: undefined, $options: 'i' } }
        ]
      });
    });

    it('should handle whitespace-only keyword', async () => {
      mockReq.params.keyword = '   ';
      mockQuery.select.mockResolvedValue([]);

      await searchProductController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        $or: [
          { name: { $regex: '   ', $options: 'i' } },
          { description: { $regex: '   ', $options: 'i' } }
        ]
      });
    });
  });

  describe('Error Cases', () => {
    it('should handle database query errors', async () => {
      const mockError = new Error('Database connection failed');
      mockQuery.select.mockRejectedValue(mockError);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await searchProductController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalledWith(mockError);
      expect(mockRes.status).toHaveBeenCalledWith(400);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'Error In Search Product API',
        error: mockError
      });

      consoleSpy.mockRestore();
    });

    it('should handle find method errors', async () => {
      const mockError = new Error('Invalid regex pattern');
      productModel.find.mockImplementation(() => {
        throw mockError;
      });

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await searchProductController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalledWith(mockError);
      expect(mockRes.status).toHaveBeenCalledWith(400);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'Error In Search Product API',
        error: mockError
      });

      consoleSpy.mockRestore();
    });

    it('should handle select method errors', async () => {
      const mockError = new Error('Select operation failed');
      mockQuery.select.mockRejectedValue(mockError);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await searchProductController(mockReq, mockRes);

      expect(mockRes.status).toHaveBeenCalledWith(400);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'Error In Search Product API',
        error: mockError
      });

      consoleSpy.mockRestore();
    });

    it('should handle malformed regex errors', async () => {
      mockReq.params.keyword = '[invalid-regex';
      const mockError = new Error('Invalid regular expression');
      mockQuery.select.mockRejectedValue(mockError);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await searchProductController(mockReq, mockRes);

      expect(mockRes.status).toHaveBeenCalledWith(400);

      consoleSpy.mockRestore();
    });
  });

  describe('Query Validation', () => {
    it('should build correct MongoDB $or query', async () => {
      mockReq.params.keyword = 'smartphone';
      mockQuery.select.mockResolvedValue([]);

      await searchProductController(mockReq, mockRes);

      const expectedQuery = {
        $or: [
          { name: { $regex: 'smartphone', $options: 'i' } },
          { description: { $regex: 'smartphone', $options: 'i' } }
        ]
      };

      expect(productModel.find).toHaveBeenCalledWith(expectedQuery);
    });

    it('should use case insensitive regex options', async () => {
      mockQuery.select.mockResolvedValue([]);

      await searchProductController(mockReq, mockRes);

      const findCall = productModel.find.mock.calls[0][0];
      expect(findCall.$or[0].name.$options).toBe('i');
      expect(findCall.$or[1].description.$options).toBe('i');
    });

    it('should search in both name and description fields', async () => {
      mockQuery.select.mockResolvedValue([]);

      await searchProductController(mockReq, mockRes);

      const findCall = productModel.find.mock.calls[0][0];
      expect(findCall.$or).toHaveLength(2);
      expect(findCall.$or[0]).toHaveProperty('name');
      expect(findCall.$or[1]).toHaveProperty('description');
    });
  });

  describe('Response Format Validation', () => {
    it('should return results directly with res.json (not wrapped)', async () => {
      const mockProducts = [{ _id: '1', name: 'Test' }];
      mockQuery.select.mockResolvedValue(mockProducts);

      await searchProductController(mockReq, mockRes);

      expect(mockRes.json).toHaveBeenCalledWith(mockProducts);
      expect(mockRes.json).toHaveBeenCalledTimes(1);
      expect(mockRes.send).not.toHaveBeenCalledWith(expect.objectContaining({
        success: true,
        products: expect.anything()
      }));
    });

    it('should not call res.status on success', async () => {
      mockQuery.select.mockResolvedValue([]);

      await searchProductController(mockReq, mockRes);

      expect(mockRes.status).not.toHaveBeenCalled();
      expect(mockRes.json).toHaveBeenCalled();
    });
  });
});

describe('realtedProductController', () => {
  let mockReq;
  let mockRes;
  let mockQuery;

  beforeEach(() => {
    jest.clearAllMocks();

    mockReq = {
      params: {
        pid: '507f1f77bcf86cd799439011',
        cid: '507f1f77bcf86cd799439012'
      }
    };

    mockRes = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn().mockReturnThis()
    };

    mockQuery = {
      select: jest.fn().mockReturnThis(),
      limit: jest.fn().mockReturnThis(),
      populate: jest.fn().mockResolvedValue([])
    };

    productModel.find = jest.fn().mockReturnValue(mockQuery);
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('Success Cases', () => {
    it('should return related products excluding current product', async () => {
      const mockProducts = [
        { _id: '1', name: 'Related Product 1', category: { name: 'Electronics' } },
        { _id: '2', name: 'Related Product 2', category: { name: 'Electronics' } }
      ];

      mockQuery.populate.mockResolvedValue(mockProducts);

      await realtedProductController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        category: '507f1f77bcf86cd799439012',
        _id: { $ne: '507f1f77bcf86cd799439011' }
      });
      expect(mockQuery.select).toHaveBeenCalledWith('-photo');
      expect(mockQuery.limit).toHaveBeenCalledWith(3);
      expect(mockQuery.populate).toHaveBeenCalledWith('category');

      expect(mockRes.status).toHaveBeenCalledWith(200);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        products: mockProducts
      });
    });

    it('should limit results to exactly 3 products', async () => {
      const mockProducts = [
        { _id: '1', name: 'Product 1' },
        { _id: '2', name: 'Product 2' },
        { _id: '3', name: 'Product 3' }
      ];

      mockQuery.populate.mockResolvedValue(mockProducts);

      await realtedProductController(mockReq, mockRes);

      expect(mockQuery.limit).toHaveBeenCalledWith(3);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        products: mockProducts
      });
    });

    it('should return empty array when no related products found', async () => {
      mockQuery.populate.mockResolvedValue([]);

      await realtedProductController(mockReq, mockRes);

      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        products: []
      });
    });

    it('should handle single related product', async () => {
      const mockProducts = [
        { _id: '1', name: 'Single Related Product', category: { name: 'Books' } }
      ];

      mockQuery.populate.mockResolvedValue(mockProducts);

      await realtedProductController(mockReq, mockRes);

      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        products: mockProducts
      });
    });

    it('should populate category field correctly', async () => {
      const mockProducts = [
        { 
          _id: '1', 
          name: 'Product 1',
          category: { 
            _id: '507f1f77bcf86cd799439012',
            name: 'Electronics',
            slug: 'electronics'
          }
        }
      ];

      mockQuery.populate.mockResolvedValue(mockProducts);

      await realtedProductController(mockReq, mockRes);

      expect(mockQuery.populate).toHaveBeenCalledWith('category');
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        products: mockProducts
      });
    });

    it('should exclude photo field from results', async () => {
      mockQuery.populate.mockResolvedValue([]);

      await realtedProductController(mockReq, mockRes);

      expect(mockQuery.select).toHaveBeenCalledWith('-photo');
    });
  });

  describe('Parameter Handling', () => {
    it('should handle different product and category IDs', async () => {
      mockReq.params.pid = '607f1f77bcf86cd799439013';
      mockReq.params.cid = '607f1f77bcf86cd799439014';

      mockQuery.populate.mockResolvedValue([]);

      await realtedProductController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        category: '607f1f77bcf86cd799439014',
        _id: { $ne: '607f1f77bcf86cd799439013' }
      });
    });

    it('should handle string parameter values', async () => {
      mockReq.params.pid = 'product123';
      mockReq.params.cid = 'category456';

      mockQuery.populate.mockResolvedValue([]);

      await realtedProductController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        category: 'category456',
        _id: { $ne: 'product123' }
      });
    });

    it('should handle undefined parameters', async () => {
      mockReq.params.pid = undefined;
      mockReq.params.cid = undefined;

      mockQuery.populate.mockResolvedValue([]);

      await realtedProductController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        category: undefined,
        _id: { $ne: undefined }
      });
    });

    it('should handle null parameters', async () => {
      mockReq.params.pid = null;
      mockReq.params.cid = null;

      mockQuery.populate.mockResolvedValue([]);

      await realtedProductController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        category: null,
        _id: { $ne: null }
      });
    });

    it('should handle empty string parameters', async () => {
      mockReq.params.pid = '';
      mockReq.params.cid = '';

      mockQuery.populate.mockResolvedValue([]);

      await realtedProductController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        category: '',
        _id: { $ne: '' }
      });
    });
  });

  describe('Error Cases', () => {
    it('should handle database query errors', async () => {
      const mockError = new Error('Database connection failed');
      mockQuery.populate.mockRejectedValue(mockError);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await realtedProductController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalledWith(mockError);
      expect(mockRes.status).toHaveBeenCalledWith(400);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'error while geting related product',
        error: mockError
      });

      consoleSpy.mockRestore();
    });

    it('should handle find method errors', async () => {
      const mockError = new Error('Invalid ObjectId format');
      productModel.find.mockImplementation(() => {
        throw mockError;
      });

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await realtedProductController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalledWith(mockError);
      expect(mockRes.status).toHaveBeenCalledWith(400);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'error while geting related product',
        error: mockError
      });

      consoleSpy.mockRestore();
    });

    it('should handle populate method errors', async () => {
      const mockError = new Error('Population failed');
      mockQuery.populate.mockRejectedValue(mockError);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await realtedProductController(mockReq, mockRes);

      expect(mockRes.status).toHaveBeenCalledWith(400);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'error while geting related product',
        error: mockError
      });

      consoleSpy.mockRestore();
    });

    it('should handle select method errors', async () => {
      const mockError = new Error('Select operation failed');
      mockQuery.select.mockImplementation(() => {
        throw mockError;
      });

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await realtedProductController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalledWith(mockError);
      expect(mockRes.status).toHaveBeenCalledWith(400);

      consoleSpy.mockRestore();
    });

    it('should handle limit method errors', async () => {
      const mockError = new Error('Limit operation failed');
      mockQuery.limit.mockImplementation(() => {
        throw mockError;
      });

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await realtedProductController(mockReq, mockRes);

      expect(mockRes.status).toHaveBeenCalledWith(400);

      consoleSpy.mockRestore();
    });
  });

  describe('Query Chain Validation', () => {
    it('should call query methods in correct order', async () => {
      mockQuery.populate.mockResolvedValue([]);

      await realtedProductController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({
        category: '507f1f77bcf86cd799439012',
        _id: { $ne: '507f1f77bcf86cd799439011' }
      });
      expect(mockQuery.select).toHaveBeenCalledWith('-photo');
      expect(mockQuery.limit).toHaveBeenCalledWith(3);
      expect(mockQuery.populate).toHaveBeenCalledWith('category');
    });

    it('should call each query method exactly once', async () => {
      mockQuery.populate.mockResolvedValue([]);

      await realtedProductController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledTimes(1);
      expect(mockQuery.select).toHaveBeenCalledTimes(1);
      expect(mockQuery.limit).toHaveBeenCalledTimes(1);
      expect(mockQuery.populate).toHaveBeenCalledTimes(1);
    });

    it('should build correct MongoDB query with $ne operator', async () => {
      mockQuery.populate.mockResolvedValue([]);

      await realtedProductController(mockReq, mockRes);

      const findCall = productModel.find.mock.calls[0][0];
      expect(findCall).toEqual({
        category: '507f1f77bcf86cd799439012',
        _id: { $ne: '507f1f77bcf86cd799439011' }
      });
    });
  });

  describe('Response Format Validation', () => {
    it('should return exact response structure on success', async () => {
      const mockProducts = [{ _id: '1', name: 'Test Product' }];
      mockQuery.populate.mockResolvedValue(mockProducts);

      await realtedProductController(mockReq, mockRes);

      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        products: mockProducts
      });
    });

    it('should return exact error response structure', async () => {
      const mockError = new Error('Test error');
      mockQuery.populate.mockRejectedValue(mockError);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await realtedProductController(mockReq, mockRes);

      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'error while geting related product',
        error: mockError
      });

      consoleSpy.mockRestore();
    });

    it('should not include extra properties in success response', async () => {
      mockQuery.populate.mockResolvedValue([]);

      await realtedProductController(mockReq, mockRes);

      const responseCall = mockRes.send.mock.calls[0][0];
      const keys = Object.keys(responseCall);

      expect(keys).toEqual(['success', 'products']);
      expect(keys).toHaveLength(2);
    });
  });

  describe('Business Logic Validation', () => {
    it('should exclude the current product from results', async () => {
      mockQuery.populate.mockResolvedValue([]);

      await realtedProductController(mockReq, mockRes);

      const findQuery = productModel.find.mock.calls[0][0];
      expect(findQuery._id.$ne).toBe('507f1f77bcf86cd799439011');
    });

    it('should only return products from the same category', async () => {
      mockQuery.populate.mockResolvedValue([]);

      await realtedProductController(mockReq, mockRes);

      const findQuery = productModel.find.mock.calls[0][0];
      expect(findQuery.category).toBe('507f1f77bcf86cd799439012');
    });

    it('should limit results to maximum 3 products for performance', async () => {
      mockQuery.populate.mockResolvedValue([]);

      await realtedProductController(mockReq, mockRes);

      expect(mockQuery.limit).toHaveBeenCalledWith(3);
    });
  });
});
