// This was generated by ChatGPT based on the original code and the following instruction:
// "help me write unit tests for this component:"
// Yes, it was asked to write for a component, but these are controllers.
// There were edits to fix issues.
import path from "path";
import { createProductController, updateProductController, deleteProductController, getProductController, getSingleProductController } from "../controllers/productController.js";
import productModel from "../models/productModel";
import fs from "fs";
import slugify from "slugify";
import { da } from "date-fns/locale";

jest.mock("../models/productModel");
jest.mock("fs", () => ({
  readFileSync: jest.fn(),
}));
jest.mock("braintree");
jest.mock("slugify", () => jest.fn((str) => str.toLowerCase().replace(/\s+/g, "-")));

describe("createProductController", () => {
  let req, res;

  beforeEach(() => {
    req = {
      fields: {
        name: "Test Product",
        description: "Test Desc",
        price: 100,
        category: "123",
        quantity: 5,
        shipping: "1",
      },
      files: {},
    };

    res = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn(),
    };

    jest.clearAllMocks();
  });

  it("should reject if no name", async () => {
    req.fields.name = "";
    await createProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Name is Required" });
  });

  it("should reject if no description", async () => {
    req.fields.description = "";
    await createProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Description is Required" });
  });

  it("should reject if no price", async () => {
    req.fields.price = null;
    await createProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Price is Required" });
  });

  it("should reject if no category", async () => {
    req.fields.category = "";
    await createProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Category is Required" });
  });

  it("should reject if no quantity", async () => {
    req.fields.quantity = null;
    await createProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Quantity is Required" });
  });

  it("should reject if no shipping", async () => {
    req.fields.shipping = null;
    await createProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Shipping is Required" });
  });

  it("should return error if photo is too large", async () => {
    req.files.photo = { path: "/tmp/photo.jpg", type: "image/jpeg", size: 2000000 };
    await createProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({
      error: "photo is Required and should be less then 1mb",
    });
  });

  it("should create product successfully with eligible photo", async () => {
    req.files.photo = { path: "/tmp/photo.jpg", type: "image/jpeg", size: 500000 };
    fs.readFileSync.mockReturnValue(Buffer.from("fake"));
    await createProductController(req, res);

    expect(slugify).toHaveBeenCalledWith("Test Product");
    expect(productModel).toHaveBeenCalledWith(
      expect.objectContaining({ 
        name: "Test Product", 
        description: "Test Desc",
        price: 100,
        category: "123",
        quantity: 5,
        shipping: "1",
        slug: "test-product",
        photo: { data: expect.any(Buffer), contentType: "image/jpeg" }
      })
    );
    expect(productModel.prototype.save).toHaveBeenCalled();
    expect(res.status).toHaveBeenCalledWith(201);
    expect(res.send).toHaveBeenCalledWith(
      expect.objectContaining({ success: true, message: "Product Created Successfully" })
    );
  });

  it("should create product successfully without photo", async () => {
    await createProductController(req, res);

    expect(slugify).toHaveBeenCalledWith("Test Product");
    expect(productModel).toHaveBeenCalledWith(
      expect.objectContaining({ 
        name: "Test Product", 
        description: "Test Desc",
        price: 100,
        category: "123",
        quantity: 5,
        slug: "test-product" 
      })
    );
    expect(productModel.prototype.save).toHaveBeenCalled();
    expect(res.status).toHaveBeenCalledWith(201);
    expect(res.send).toHaveBeenCalledWith(
      expect.objectContaining({ success: true, message: "Product Created Successfully" })
    );
  });

  it("should handle save errors gracefully", async () => {
    productModel.mockImplementation(() => ({
      save: jest.fn().mockRejectedValue(new Error("DB error")),
    }));

    await createProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith(
      expect.objectContaining({ success: false, message: "Error in crearing product" })
    );
  });
});

describe("deleteProductController", () => {
  let req, res;

  beforeEach(() => {
    req = { params: { pid: "123" } };
    res = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn(),
    };
    jest.clearAllMocks();
  });

  it("should delete a product successfully", async () => {
    const selectMock = jest.fn().mockResolvedValue({ _id: "123" });
    productModel.findByIdAndDelete.mockReturnValue({ select: selectMock });

    await deleteProductController(req, res);

    expect(productModel.findByIdAndDelete).toHaveBeenCalledWith("123");
    expect(selectMock).toHaveBeenCalledWith("-photo");
    expect(res.status).toHaveBeenCalledWith(200);
    expect(res.send).toHaveBeenCalledWith({
      success: true,
      message: "Product Deleted Successfully",
    });
  });

  it("should handle errors gracefully", async () => {
    const error = new Error("DB error");
    const selectMock = jest.fn().mockRejectedValue(error);
    productModel.findByIdAndDelete.mockReturnValue({ select: selectMock });

    await deleteProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({
      success: false,
      message: "Error while deleting product",
      error,
    });
  });
});

describe("updateProductController", () => {
  let req, res, mockProduct;

  beforeEach(() => {
    mockProduct = {
      save: jest.fn().mockResolvedValue({ _id: "1" }),
      photo: {},
    };

    req = {
      params: { pid: "123" },
      fields: {
        name: "Test Product",
        description: "Test Desc",
        price: 100,
        category: "cat123",
        quantity: 5,
        shipping: "1",
      },
      files: {},
    };

    res = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn(),
    };

    productModel.findByIdAndUpdate.mockResolvedValue(mockProduct);
    jest.clearAllMocks();
  });

  it("should reject if no name", async () => {
    req.fields.name = "";
    await updateProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Name is Required" });
  });

  it("should reject if no description", async () => {
    req.fields.description = "";
    await updateProductController(req, res);
    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Description is Required" });
  });

  it("should reject if no price", async () => {
    req.fields.price = null;
    await updateProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Price is Required" });
  });

  it("should reject if no category", async () => {
    req.fields.category = "";
    await updateProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Category is Required" });
  });

  it("should reject if no quantity", async () => {
    req.fields.quantity = null;
    await updateProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Quantity is Required" });
  });

  it("should reject if no shipping", async () => {
    req.fields.shipping = null;
    await updateProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Shipping is Required" });
  });

  it("should return error if photo is too large", async () => {
    req.files.photo = { path: "/tmp/photo.jpg", type: "image/jpeg", size: 2000000 };

    await updateProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({
      error: "Photo is required and should be less then 1mb",
    });
  });

  it("should update a product successfully with photo", async () => {
    req.files.photo = { path: "/tmp/photo.jpg", type: "image/jpeg", size: 500000 };
    fs.readFileSync.mockReturnValue(Buffer.from("fake"));

    await updateProductController(req, res);

    expect(slugify).toHaveBeenCalledWith("Test Product");
    expect(productModel.findByIdAndUpdate).toHaveBeenCalledWith(
      "123",
      expect.objectContaining(
        {
          name: "Test Product",
          description: "Test Desc",
          price: 100,
          category: "cat123",
          quantity: 5,
          shipping: "1",
          slug: "test-product",
          photo: { data: expect.any(Buffer), contentType: "image/jpeg" }
        }
      ),
      { new: true }
    );
    expect(mockProduct.save).toHaveBeenCalled();
    expect(res.status).toHaveBeenCalledWith(201);
    expect(res.send).toHaveBeenCalledWith(
      expect.objectContaining({ success: true, message: "Product Updated Successfully" })
    );
  });

  it("should update a product successfully without photo", async () => {
    await updateProductController(req, res);

    expect(slugify).toHaveBeenCalledWith("Test Product");
    expect(productModel.findByIdAndUpdate).toHaveBeenCalledWith(
      "123",
      expect.objectContaining(
        {
          name: "Test Product",
          description: "Test Desc",
          price: 100,
          category: "cat123",
          quantity: 5,
          shipping: "1",
          slug: "test-product"
        }
      ),
      { new: true }
    );
    expect(mockProduct.save).toHaveBeenCalled();
    expect(res.status).toHaveBeenCalledWith(201);
    expect(res.send).toHaveBeenCalledWith(
      expect.objectContaining({ success: true, message: "Product Updated Successfully" })
    );
  });

  it("should handle database errors gracefully", async () => {
    productModel.findByIdAndUpdate.mockRejectedValue(new Error("DB error"));

    await updateProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith(
      expect.objectContaining({ success: false, message: "Error in Updating product" })
    );
  });
});

describe('getProductController', () => {
  let mockReq;
  let mockRes;
  let mockQuery;

  beforeEach(() => {
    jest.clearAllMocks();

    mockReq = {};

    mockRes = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn().mockReturnThis()
    };

    mockQuery = {
      populate: jest.fn().mockReturnThis(),
      select: jest.fn().mockReturnThis(),
      limit: jest.fn().mockReturnThis(),
      sort: jest.fn().mockResolvedValue([])
    };

    productModel.find = jest.fn().mockReturnValue(mockQuery);
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('Success Cases', () => {
    it('should return products with correct response format', async () => {
      const mockProducts = [
        { _id: '1', name: 'Product 1', category: { name: 'Category 1' } },
        { _id: '2', name: 'Product 2', category: { name: 'Category 2' } }
      ];

      mockQuery.sort.mockResolvedValue(mockProducts);

      await getProductController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledWith({});
      expect(mockQuery.populate).toHaveBeenCalledWith('category');
      expect(mockQuery.select).toHaveBeenCalledWith('-photo');
      expect(mockQuery.limit).toHaveBeenCalledWith(12);
      expect(mockQuery.sort).toHaveBeenCalledWith({ createdAt: -1 });

      expect(mockRes.status).toHaveBeenCalledWith(200);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        countTotal: 2,
        message: 'All Products',
        products: mockProducts
      });
    });

    it('should handle empty product list', async () => {
      const mockProducts = [];
      mockQuery.sort.mockResolvedValue(mockProducts);

      await getProductController(mockReq, mockRes);

      expect(mockRes.status).toHaveBeenCalledWith(200);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        countTotal: 0,
        message: 'All Products',
        products: []
      });
    });

    it('should limit results to exactly 12 products', async () => {
      const mockProducts = Array.from({ length: 12 }, (_, i) => ({
        _id: `${i + 1}`,
        name: `Product ${i + 1}`,
        category: { name: `Category ${i + 1}` }
      }));

      mockQuery.sort.mockResolvedValue(mockProducts);

      await getProductController(mockReq, mockRes);

      expect(mockQuery.limit).toHaveBeenCalledWith(12);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        countTotal: 12,
        message: 'All Products',
        products: mockProducts
      });
    });
  });

  describe('Error Cases', () => {
    it('should handle database query errors', async () => {
      const mockError = new Error('Database connection failed');
      mockQuery.sort.mockRejectedValue(mockError);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await getProductController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalledWith(mockError);

      expect(mockRes.status).toHaveBeenCalledWith(500);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'Erorr in getting products',
        error: 'Database connection failed'
      });

      consoleSpy.mockRestore();
    });

    it('should handle populate method errors', async () => {
      const mockError = new Error('Population failed');
      mockQuery.populate.mockImplementation(() => {
        throw mockError;
      });

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await getProductController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalledWith(mockError);
      expect(mockRes.status).toHaveBeenCalledWith(500);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'Erorr in getting products',
        error: 'Population failed'
      });

      consoleSpy.mockRestore();
    });

    it('should handle errors without message property', async () => {
      const mockError = 'String error without message property';
      mockQuery.sort.mockRejectedValue(mockError);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await getProductController(mockReq, mockRes);

      expect(mockRes.status).toHaveBeenCalledWith(500);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'Erorr in getting products',
        error: undefined
      });

      consoleSpy.mockRestore();
    });
  });

  describe('Query Chain Validation', () => {
    it('should call query methods in correct order', async () => {
      const mockProducts = [{ _id: '1', name: 'Test Product' }];
      mockQuery.sort.mockResolvedValue(mockProducts);

      await getProductController(mockReq, mockRes);

      const findCall = productModel.find.mock.calls[0];
      const populateCall = mockQuery.populate.mock.calls[0];
      const selectCall = mockQuery.select.mock.calls[0];
      const limitCall = mockQuery.limit.mock.calls[0];
      const sortCall = mockQuery.sort.mock.calls[0];

      expect(findCall).toEqual([{}]);
      expect(populateCall).toEqual(['category']);
      expect(selectCall).toEqual(['-photo']);
      expect(limitCall).toEqual([12]);
      expect(sortCall).toEqual([{ createdAt: -1 }]);
    });

    it('should ensure all query methods are called exactly once', async () => {
      const mockProducts = [];
      mockQuery.sort.mockResolvedValue(mockProducts);

      await getProductController(mockReq, mockRes);

      expect(productModel.find).toHaveBeenCalledTimes(1);
      expect(mockQuery.populate).toHaveBeenCalledTimes(1);
      expect(mockQuery.select).toHaveBeenCalledTimes(1);
      expect(mockQuery.limit).toHaveBeenCalledTimes(1);
      expect(mockQuery.sort).toHaveBeenCalledTimes(1);
    });
  });
});

describe('getSingleProductController', () => {
  let mockReq;
  let mockRes;
  let mockQuery;

  beforeEach(() => {
    jest.clearAllMocks();

    mockReq = {
      params: {
        slug: 'test-product-slug'
      }
    };

    mockRes = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn().mockReturnThis()
    };

    mockQuery = {
      select: jest.fn().mockReturnThis(),
      populate: jest.fn().mockResolvedValue(null)
    };

    productModel.findOne = jest.fn().mockReturnValue(mockQuery);
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('Success Cases', () => {
    it('should return product when found by slug', async () => {
      const mockProduct = {
        _id: '1',
        name: 'Test Product',
        slug: 'test-product-slug',
        description: 'Test description',
        price: 99.99,
        category: {
          _id: 'cat1',
          name: 'Test Category'
        }
      };

      mockQuery.populate.mockResolvedValue(mockProduct);

      await getSingleProductController(mockReq, mockRes);

      expect(productModel.findOne).toHaveBeenCalledWith({ slug: 'test-product-slug' });
      expect(mockQuery.select).toHaveBeenCalledWith('-photo');
      expect(mockQuery.populate).toHaveBeenCalledWith('category');

      expect(mockRes.status).toHaveBeenCalledWith(200);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        message: 'Single Product Fetched',
        product: mockProduct
      });
    });

    it('should return null when product not found', async () => {
      mockQuery.populate.mockResolvedValue(null);

      await getSingleProductController(mockReq, mockRes);

      expect(productModel.findOne).toHaveBeenCalledWith({ slug: 'test-product-slug' });
      expect(mockRes.status).toHaveBeenCalledWith(200);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        message: 'Single Product Fetched',
        product: null
      });
    });

    it('should handle different slug values', async () => {
      mockReq.params.slug = 'another-product-123';
      const mockProduct = { _id: '2', name: 'Another Product', slug: 'another-product-123' };
      mockQuery.populate.mockResolvedValue(mockProduct);

      await getSingleProductController(mockReq, mockRes);

      expect(productModel.findOne).toHaveBeenCalledWith({ slug: 'another-product-123' });
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        message: 'Single Product Fetched',
        product: mockProduct
      });
    });

    it('should populate category field correctly', async () => {
      const mockProduct = {
        _id: '1',
        name: 'Test Product',
        category: {
          _id: 'cat1',
          name: 'Electronics',
          slug: 'electronics'
        }
      };
      mockQuery.populate.mockResolvedValue(mockProduct);

      await getSingleProductController(mockReq, mockRes);

      expect(mockQuery.populate).toHaveBeenCalledWith('category');
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        message: 'Single Product Fetched',
        product: mockProduct
      });
    });
  });

  describe('Error Cases', () => {
    it('should handle database query errors', async () => {
      const mockError = new Error('Database connection failed');
      mockQuery.populate.mockRejectedValue(mockError);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await getSingleProductController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalledWith(mockError);

      expect(mockRes.status).toHaveBeenCalledWith(500);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'Eror while getitng single product',
        error: mockError
      });

      consoleSpy.mockRestore();
    });

    it('should handle findOne method errors', async () => {
      const mockError = new Error('Invalid slug format');
      productModel.findOne.mockImplementation(() => {
        throw mockError;
      });

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await getSingleProductController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalledWith(mockError);
      expect(mockRes.status).toHaveBeenCalledWith(500);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'Eror while getitng single product',
        error: mockError
      });

      consoleSpy.mockRestore();
    });

    it('should handle populate method errors', async () => {
      const mockError = new Error('Population failed for category');
      mockQuery.populate.mockRejectedValue(mockError);

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await getSingleProductController(mockReq, mockRes);

      expect(consoleSpy).toHaveBeenCalledWith(mockError);
      expect(mockRes.status).toHaveBeenCalledWith(500);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: false,
        message: 'Eror while getitng single product',
        error: mockError
      });

      consoleSpy.mockRestore();
    });

    it('should handle missing slug parameter', async () => {
      mockReq.params.slug = undefined;
      mockQuery.populate.mockResolvedValue(null);

      await getSingleProductController(mockReq, mockRes);

      expect(productModel.findOne).toHaveBeenCalledWith({ slug: undefined });
      expect(mockRes.status).toHaveBeenCalledWith(200);
      expect(mockRes.send).toHaveBeenCalledWith({
        success: true,
        message: 'Single Product Fetched',
        product: null
      });
    });
  });

  describe('Query Chain Validation', () => {
    it('should call query methods in correct order', async () => {
      const mockProduct = { _id: '1', name: 'Test Product' };
      mockQuery.populate.mockResolvedValue(mockProduct);

      await getSingleProductController(mockReq, mockRes);

      const findOneCall = productModel.findOne.mock.calls[0];
      const selectCall = mockQuery.select.mock.calls[0];
      const populateCall = mockQuery.populate.mock.calls[0];

      expect(findOneCall).toEqual([{ slug: 'test-product-slug' }]);
      expect(selectCall).toEqual(['-photo']);
      expect(populateCall).toEqual(['category']);
    });

    it('should ensure all query methods are called exactly once', async () => {
      mockQuery.populate.mockResolvedValue(null);

      await getSingleProductController(mockReq, mockRes);

      expect(productModel.findOne).toHaveBeenCalledTimes(1);
      expect(mockQuery.select).toHaveBeenCalledTimes(1);
      expect(mockQuery.populate).toHaveBeenCalledTimes(1);
    });

    it('should exclude photo field from selection', async () => {
      mockQuery.populate.mockResolvedValue({ _id: '1', name: 'Test' });

      await getSingleProductController(mockReq, mockRes);

      expect(mockQuery.select).toHaveBeenCalledWith('-photo');
    });
  });

  describe('Request Parameter Handling', () => {
    it('should handle special characters in slug', async () => {
      mockReq.params.slug = 'product-with-special-chars-&-symbols';
      mockQuery.populate.mockResolvedValue(null);

      await getSingleProductController(mockReq, mockRes);

      expect(productModel.findOne).toHaveBeenCalledWith({ 
        slug: 'product-with-special-chars-&-symbols' 
      });
    });

    it('should handle empty string slug', async () => {
      mockReq.params.slug = '';
      mockQuery.populate.mockResolvedValue(null);

      await getSingleProductController(mockReq, mockRes);

      expect(productModel.findOne).toHaveBeenCalledWith({ slug: '' });
    });

    it('should handle numeric slug values', async () => {
      mockReq.params.slug = '12345';
      mockQuery.populate.mockResolvedValue(null);

      await getSingleProductController(mockReq, mockRes);

      expect(productModel.findOne).toHaveBeenCalledWith({ slug: '12345' });
    });
  });
});

