// This was generated by ChatGPT based on the original code and the following instruction:
// "help me write unit tests for this component:"
// Yes, it was asked to write for a component, but these are controllers.
// There were edits to fix issues.
import { createProductController, updateProductController, deleteProductController, braintreeTokenController, brainTreePaymentController, gateway } from "../controllers/productController.js";
import productModel from "../models/productModel";
import orderModel from "../models/orderModel.js";
import fs from "fs";
import slugify from "slugify";

jest.mock("../models/productModel");
jest.mock("fs", () => ({
  readFileSync: jest.fn(),
}));
jest.mock("braintree");
jest.mock("../models/orderModel.js", () => ({
  __esModule: true,
  default: jest.fn().mockImplementation(() => ({
    save: jest.fn().mockResolvedValue(true),
  })),
}));
jest.mock("slugify", () => jest.fn((str) => str.toLowerCase().replace(/\s+/g, "-")));

describe("createProductController", () => {
  let req, res;

  beforeEach(() => {
    req = {
      fields: {
        name: "Test Product",
        description: "Test Desc",
        price: 100,
        category: "123",
        quantity: 5,
        shipping: "1",
      },
      files: {},
    };

    res = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn(),
    };

    jest.clearAllMocks();
  });

  it("should reject if no name", async () => {
    req.fields.name = "";
    await createProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Name is Required" });
  });

  it("should reject if no description", async () => {
    req.fields.description = "";
    await createProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Description is Required" });
  });

  it("should reject if no price", async () => {
    req.fields.price = null;
    await createProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Price is Required" });
  });

  it("should reject if no category", async () => {
    req.fields.category = "";
    await createProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Category is Required" });
  });

  it("should reject if no quantity", async () => {
    req.fields.quantity = null;
    await createProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Quantity is Required" });
  });

  it("should reject if no shipping", async () => {
    req.fields.shipping = null;
    await createProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Shipping is Required" });
  });

  it("should return error if photo is too large", async () => {
    req.files.photo = { path: "/tmp/photo.jpg", type: "image/jpeg", size: 2000000 };
    await createProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({
      error: "photo is Required and should be less then 1mb",
    });
  });

  it("should create product successfully with eligible photo", async () => {
    req.files.photo = { path: "/tmp/photo.jpg", type: "image/jpeg", size: 500000 };
    fs.readFileSync.mockReturnValue(Buffer.from("fake"));
    await createProductController(req, res);

    expect(slugify).toHaveBeenCalledWith("Test Product");
    expect(productModel).toHaveBeenCalledWith(
      expect.objectContaining({ 
        name: "Test Product", 
        description: "Test Desc",
        price: 100,
        category: "123",
        quantity: 5,
        shipping: "1",
        slug: "test-product",
        photo: { data: expect.any(Buffer), contentType: "image/jpeg" }
      })
    );
    expect(productModel.prototype.save).toHaveBeenCalled();
    expect(res.status).toHaveBeenCalledWith(201);
    expect(res.send).toHaveBeenCalledWith(
      expect.objectContaining({ success: true, message: "Product Created Successfully" })
    );
  });

  it("should create product successfully without photo", async () => {
    await createProductController(req, res);

    expect(slugify).toHaveBeenCalledWith("Test Product");
    expect(productModel).toHaveBeenCalledWith(
      expect.objectContaining({ 
        name: "Test Product", 
        description: "Test Desc",
        price: 100,
        category: "123",
        quantity: 5,
        slug: "test-product" 
      })
    );
    expect(productModel.prototype.save).toHaveBeenCalled();
    expect(res.status).toHaveBeenCalledWith(201);
    expect(res.send).toHaveBeenCalledWith(
      expect.objectContaining({ success: true, message: "Product Created Successfully" })
    );
  });

  it("should handle save errors gracefully", async () => {
    productModel.mockImplementation(() => ({
      save: jest.fn().mockRejectedValue(new Error("DB error")),
    }));

    await createProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith(
      expect.objectContaining({ success: false, message: "Error in crearing product" })
    );
  });
});

describe("deleteProductController", () => {
  let req, res;

  beforeEach(() => {
    req = { params: { pid: "123" } };
    res = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn(),
    };
    jest.clearAllMocks();
  });

  it("should delete a product successfully", async () => {
    const selectMock = jest.fn().mockResolvedValue({ _id: "123" });
    productModel.findByIdAndDelete.mockReturnValue({ select: selectMock });

    await deleteProductController(req, res);

    expect(productModel.findByIdAndDelete).toHaveBeenCalledWith("123");
    expect(selectMock).toHaveBeenCalledWith("-photo");
    expect(res.status).toHaveBeenCalledWith(200);
    expect(res.send).toHaveBeenCalledWith({
      success: true,
      message: "Product Deleted Successfully",
    });
  });

  it("should handle errors gracefully", async () => {
    const error = new Error("DB error");
    const selectMock = jest.fn().mockRejectedValue(error);
    productModel.findByIdAndDelete.mockReturnValue({ select: selectMock });

    await deleteProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({
      success: false,
      message: "Error while deleting product",
      error,
    });
  });
});

describe("updateProductController", () => {
  let req, res, mockProduct;

  beforeEach(() => {
    mockProduct = {
      save: jest.fn().mockResolvedValue({ _id: "1" }),
      photo: {},
    };

    req = {
      params: { pid: "123" },
      fields: {
        name: "Test Product",
        description: "Test Desc",
        price: 100,
        category: "cat123",
        quantity: 5,
        shipping: "1",
      },
      files: {},
    };

    res = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn(),
    };

    productModel.findByIdAndUpdate.mockResolvedValue(mockProduct);
    jest.clearAllMocks();
  });

  it("should reject if no name", async () => {
    req.fields.name = "";
    await updateProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Name is Required" });
  });

  it("should reject if no description", async () => {
    req.fields.description = "";
    await updateProductController(req, res);
    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Description is Required" });
  });

  it("should reject if no price", async () => {
    req.fields.price = null;
    await updateProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Price is Required" });
  });

  it("should reject if no category", async () => {
    req.fields.category = "";
    await updateProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Category is Required" });
  });

  it("should reject if no quantity", async () => {
    req.fields.quantity = null;
    await updateProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Quantity is Required" });
  });

  it("should reject if no shipping", async () => {
    req.fields.shipping = null;
    await updateProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Shipping is Required" });
  });

  it("should return error if photo is too large", async () => {
    req.files.photo = { path: "/tmp/photo.jpg", type: "image/jpeg", size: 2000000 };

    await updateProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({
      error: "Photo is required and should be less then 1mb",
    });
  });

  it("should update a product successfully with photo", async () => {
    req.files.photo = { path: "/tmp/photo.jpg", type: "image/jpeg", size: 500000 };
    fs.readFileSync.mockReturnValue(Buffer.from("fake"));

    await updateProductController(req, res);

    expect(slugify).toHaveBeenCalledWith("Test Product");
    expect(productModel.findByIdAndUpdate).toHaveBeenCalledWith(
      "123",
      expect.objectContaining(
        {
          name: "Test Product",
          description: "Test Desc",
          price: 100,
          category: "cat123",
          quantity: 5,
          shipping: "1",
          slug: "test-product",
          photo: { data: expect.any(Buffer), contentType: "image/jpeg" }
        }
      ),
      { new: true }
    );
    expect(mockProduct.save).toHaveBeenCalled();
    expect(res.status).toHaveBeenCalledWith(201);
    expect(res.send).toHaveBeenCalledWith(
      expect.objectContaining({ success: true, message: "Product Updated Successfully" })
    );
  });

  it("should update a product successfully without photo", async () => {
    await updateProductController(req, res);

    expect(slugify).toHaveBeenCalledWith("Test Product");
    expect(productModel.findByIdAndUpdate).toHaveBeenCalledWith(
      "123",
      expect.objectContaining(
        {
          name: "Test Product",
          description: "Test Desc",
          price: 100,
          category: "cat123",
          quantity: 5,
          shipping: "1",
          slug: "test-product"
        }
      ),
      { new: true }
    );
    expect(mockProduct.save).toHaveBeenCalled();
    expect(res.status).toHaveBeenCalledWith(201);
    expect(res.send).toHaveBeenCalledWith(
      expect.objectContaining({ success: true, message: "Product Updated Successfully" })
    );
  });

  it("should handle database errors gracefully", async () => {
    productModel.findByIdAndUpdate.mockRejectedValue(new Error("DB error"));

    await updateProductController(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith(
      expect.objectContaining({ success: false, message: "Error in Updating product" })
    );
  });
});

describe("Braintree Controllers", () => {
  let req, res;

  beforeEach(() => {
    req = {};
    res = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn(),
      json: jest.fn(),
    };
  });

  describe("braintreeTokenController", () => {
    let req, res;

    beforeEach(() => {
      req = {};
      res = {
        send: jest.fn(),
        status: jest.fn().mockReturnThis(),
      };
    });

    it("should send token response on success", async () => {
      jest.spyOn(gateway.clientToken, "generate").mockImplementation((_, callback) => {
        callback(null, { clientToken: "fake-token" });
      });

      await braintreeTokenController(req, res);

      expect(gateway.clientToken.generate).toHaveBeenCalledWith({}, expect.any(Function));
      expect(res.send).toHaveBeenCalledWith({ clientToken: "fake-token" });
    });

    it("should return 500 on error", async () => {
      jest.spyOn(gateway.clientToken, "generate").mockImplementation((_, callback) => {
        callback("error generating token", null);
      });

      await braintreeTokenController(req, res);

      expect(res.status).toHaveBeenCalledWith(500);
      expect(res.send).toHaveBeenCalledWith("error generating token");
    });
  });

  describe("brainTreePaymentController", () => {
    let req, res;

    beforeEach(() => {
      req = {
        body: {
          nonce: "fake-nonce",
          cart: [
            { price: 10 },
            { price: 20 },
          ],
        },
        user: { _id: "user123" },
      };

      res = {
        json: jest.fn(),
        status: jest.fn().mockReturnThis(),
        send: jest.fn(),
      };
    });

    gateway.clientToken = { generate: jest.fn() };
    gateway.transaction = { sale: jest.fn() };

    it("should create transaction and save order on success", async () => {
      jest.spyOn(gateway.transaction, "sale").mockImplementation((data, callback) => {
        expect(data).toEqual({
          amount: 30,
          paymentMethodNonce: "fake-nonce",
          options: { submitForSettlement: true },
        });
        callback(null, { success: true });
      });

      await brainTreePaymentController(req, res);
      
      expect(gateway.transaction.sale).toHaveBeenCalledTimes(1);
      expect(res.json).toHaveBeenCalledWith({ ok: true });
      expect(orderModel).toHaveBeenCalledWith({
        products: req.body.cart,
        payment: { success: true },
        buyer: req.user._id,
      });
    });

    it("should handle transaction error", async () => {
      jest.spyOn(gateway.transaction, "sale").mockImplementation((data, callback) => {
        callback("some error", null);
      });

      await brainTreePaymentController(req, res);

      expect(res.status).toHaveBeenCalledWith(500);
      expect(res.send).toHaveBeenCalledWith("some error");
    });
  });
});