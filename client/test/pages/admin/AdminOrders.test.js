// This was generated by ChatGPT based on the original code and the following instruction:
// "create unit tests for this:"
// There were edits to fix issues.
import React from "react";
import { render, screen, waitFor, fireEvent } from "@testing-library/react";
import AdminOrders from "client/src/pages/admin/AdminOrders";
import axios from "axios";
import toast from "react-hot-toast";
import { mock } from "node:test";

// mock axios + toast
jest.mock("axios");
jest.mock("react-hot-toast", () => ({
  success: jest.fn(),
  error: jest.fn(),
}));
jest.mock("client/src/components/Layout", () => ({ children }) => (
  <div>Mocked Layout {children}</div>
));
jest.mock("client/src/components/AdminMenu", () => () => <div>Mocked AdminMenu</div>);

// mock useAuth
let mockAuthValue;
jest.mock("client/src/context/auth", () => ({
  useAuth: () => [mockAuthValue, jest.fn()],
}));

describe("AdminOrders Component", () => {
  let orders;
  beforeEach(() => {
    jest.resetAllMocks();
    orders = [
      {
        _id: "o1",
        status: "Processing",
        buyer: { name: "John Doe" },
        createdAt: new Date().toISOString(),
        payment: { success: true },
        products: [
          {
            _id: "p1",
            name: "Product 1",
            description: "This is product 1 description",
            price: 100,
          },
        ],
      },
    ];
    mockAuthValue = { token: "valid-token", user: { name: "Admin", role: 1 } };
  });

  test("fetches and displays orders", async () => {
    axios.get.mockResolvedValueOnce({
      data: orders,
    });

    render(<AdminOrders />);

    await waitFor(() => {
      expect(axios.get).toHaveBeenCalledWith("/api/v1/auth/all-orders");
      expect(screen.getByText(/mocked layout/i)).toBeInTheDocument();
      expect(screen.getByText(/mocked adminmenu/i)).toBeInTheDocument();
      expect(screen.getByText(/processing/i)).toBeInTheDocument();
      expect(screen.getByText(/all orders/i)).toBeInTheDocument();
      expect(screen.getByText("John Doe")).toBeInTheDocument();
      expect(screen.getByText(/Product 1/)).toBeInTheDocument();
      expect(screen.getByText(/Price : 100/)).toBeInTheDocument();
      expect(screen.getByText(/a few seconds ago/i)).toBeInTheDocument();
      expect(screen.getByText(/Success/)).toBeInTheDocument();
    });
  });

  test("shows error toast if fetching orders fails", async () => {
    axios.get.mockRejectedValueOnce(new Error("Network error"));

    render(<AdminOrders />);

    await waitFor(() =>
      expect(toast.error).toHaveBeenCalledWith("Something went wrong")
    );
  });

   test("shows error toast if fetching orders returns empty object", async () => {
    axios.get.mockResolvedValueOnce({});

    render(<AdminOrders />);

    await waitFor(() =>
      expect(toast.error).toHaveBeenCalledWith("Something went wrong")
    );
  });

  test("updates order status successfully", async () => {
    axios.get.mockResolvedValueOnce({
      data: [{
        _id: "o1",
        status: "Processing",
        buyer: { name: "John Doe" },
        createdAt: new Date().toISOString(),
        payment: { success: false },
        products: [
          {
            _id: "p1",
            name: "Product 1",
            description: "This is product 1 description",
            price: 100,
          },
        ],
      },],
    });

    axios.put.mockResolvedValueOnce({ data: "foo" });

    render(<AdminOrders />);

    await waitFor(() =>
      expect(screen.getByText("John Doe")).toBeInTheDocument()
    );

    fireEvent.mouseDown(screen.getByText("Processing"));
    await waitFor(() => screen.getAllByText("Processing"));
    fireEvent.click(screen.getByText("Delivered"));

    await waitFor(() => {
      expect(axios.put).toHaveBeenCalledWith(
        "/api/v1/auth/order-status/o1",
        { status: "Delivered" }
      );
      expect(toast.success).toHaveBeenCalledWith("Status Updated");
    });
  });

    test("displays toast on unsuccessful status update", async () => {
    axios.get.mockResolvedValueOnce({
      data: orders,
    });

    axios.put.mockResolvedValueOnce({});

    render(<AdminOrders />);

    await waitFor(() =>
      expect(screen.getByText("John Doe")).toBeInTheDocument()
    );

    fireEvent.mouseDown(screen.getByText("Processing"));
    await waitFor(() => screen.getAllByText("Processing"));
    fireEvent.click(screen.getByText("Delivered"));

    await waitFor(() => {
      expect(axios.put).toHaveBeenCalledWith(
        "/api/v1/auth/order-status/o1",
        { status: "Delivered" }
      );
      expect(toast.error).toHaveBeenCalledWith("Something went wrong");
    });
  });

  test("does not fetch orders if no auth token", async () => {
    mockAuthValue = null;

    render(<AdminOrders />);

    await waitFor(() => {
      expect(axios.get).not.toHaveBeenCalled();
    });
  });
});
