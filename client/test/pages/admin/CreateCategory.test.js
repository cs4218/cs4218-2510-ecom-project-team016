// This was initially generated by ChatGPT based on the original code and the following instruction:
// "help me write unit tests for this component:"
// There were edits to fix issues.
import React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import CreateCategory from "client/src/pages/admin/CreateCategory";
import axios from "axios";
import toast from "react-hot-toast";
import { afterEach } from "node:test";

// Mock dependencies
jest.mock("axios");
jest.mock("react-hot-toast", () => ({
  success: jest.fn(),
  error: jest.fn(),
}));
jest.mock("client/src/components/Layout", () => ({ children }) => (
  <div>Mocked Layout {children}</div>
));
jest.mock("client/src/components/AdminMenu", () => () => <div>Mocked AdminMenu</div>);
jest.mock("client/src/components/Form/CategoryForm", () => ({ value, setValue, handleSubmit }) => (
  <form onSubmit={handleSubmit}>
    <input
      placeholder="Enter new category"
      value={value}
      onChange={(e) => setValue(e.target.value)}
    />
    <button type="submit">Submit</button>
  </form>
));

describe("CreateCategory", () => {
  beforeEach(() => {
    jest.resetAllMocks();
  });

  test("renders layout, admin menu, and headings", async () => {
    axios.get.mockResolvedValueOnce({ data: { success: true, category: [] } });
    render(<CreateCategory />);

    await waitFor(() => {
        expect(screen.getByText(/Mocked Layout/i)).toBeInTheDocument();
        expect(screen.getByText(/Mocked AdminMenu/i)).toBeInTheDocument();
        expect(screen.getByText(/Manage Category/i)).toBeInTheDocument();
        expect(screen.getByText(/Name/i)).toBeInTheDocument();
        expect(screen.getByText(/Actions/i)).toBeInTheDocument();
    });
  });

  // Assume categories are formatted as { _id: string, name: string }, and successful responses are well-formed
  test("loads categories on mount", async () => {
    axios.get.mockResolvedValueOnce({
      data: { success: true, category: [{ _id: "1", name: "Books" }] },
    });

    render(<CreateCategory />);

    await waitFor(() => {
      expect(screen.getByText("Books")).toBeInTheDocument();
      expect(screen.getByText("Edit")).toBeInTheDocument();
      expect(screen.getByText("Delete")).toBeInTheDocument();
    });
  });

  test("renders toast when category loading fails", async () => {
    axios.get.mockResolvedValueOnce({data: { success: false }});

    render(<CreateCategory />);

    await waitFor(() =>
      expect(toast.error).toHaveBeenCalledWith(
        "Something went wrong in getting categories"
      )
    );
  });

  test("creates a new category successfully", async () => {
    axios.get
        .mockResolvedValueOnce({ data: { success: true, category: [] } })
        .mockResolvedValueOnce({ data: { success: true, category: [{ _id: "1", name: "Music" }] }});
    axios.post.mockResolvedValueOnce({ data: { success: true } });
    render(<CreateCategory />);

    fireEvent.change(screen.getByPlaceholderText(/Enter new category/i), {
      target: { value: "Music" },
    });
    fireEvent.submit(screen.getByRole("button", { name: /Submit/i }));

    await waitFor(() => {
      expect(axios.post).toHaveBeenCalledWith(expect.any(String), { name: "Music" });
      expect(toast.success).toHaveBeenCalledWith("Music is created");
      expect(screen.getByText("Music")).toBeInTheDocument();
    });
  });

  test("handles category creation POST error", async () => {
    axios.get.mockResolvedValueOnce({ data: { success: true, category: [] } });
    axios.post.mockRejectedValueOnce(new Error("Network error"));

    render(<CreateCategory />);

    fireEvent.change(screen.getByPlaceholderText(/Enter new category/i), {
      target: { value: "FailCat" },
    });
    fireEvent.click(screen.getByRole("button", { name: /Submit/i }));

    await waitFor(() =>
      expect(toast.error).toHaveBeenCalledWith(
        "somthing went wrong in input form"
      )
    );
  });

  test("handles category creation unsuccessful response", async () => {
    axios.get.mockResolvedValueOnce({ data: { success: true, category: [] } });
    axios.post.mockResolvedValueOnce({ data: { success: false, message: "Creation failed" } });

    render(<CreateCategory />);

    fireEvent.change(screen.getByPlaceholderText(/Enter new category/i), {
      target: { value: "FailCat" },
    });
    fireEvent.click(screen.getByRole("button", { name: /Submit/i }));

    await waitFor(() =>
      expect(toast.error).toHaveBeenCalledWith(
        "Creation failed"
      )
    );
  });

  test("shows modal on edit button click", async () => {
    axios.get.mockResolvedValueOnce({
      data: { success: true, category: [{ _id: "2", name: "Movies" }] },
    });

    render(<CreateCategory />);

    await waitFor(() => {
        expect(screen.getAllByPlaceholderText(/Enter new category/i)).toHaveLength(1); // Only the create form is visible initially
        screen.getByText("Movies");
    });

    fireEvent.click(screen.getByRole("button", { name: /Edit/i }));

    await waitFor(() =>
      expect(screen.getAllByPlaceholderText(/Enter new category/i)[1]).toBeVisible()
    );
  });

  test("hides modal on close", async () => {
    axios.get.mockResolvedValueOnce({
      data: { success: true, category: [{ _id: "2", name: "Movies" }] },
    });

    render(<CreateCategory />);

    await waitFor(() => screen.getByText("Movies"));

    fireEvent.click(screen.getByRole("button", { name: /Edit/i }));

    await waitFor(() =>
      expect(screen.getAllByPlaceholderText(/Enter new category/i)[1]).toBeVisible()
    );

    fireEvent.click(screen.getByRole("button", { name: /Close/i }));

    await waitFor(() => {
      expect(screen.getAllByPlaceholderText(/Enter new category/i)[1]).not.toBeVisible();
    });
  });

  test("updates a category", async () => {
    axios.get.mockResolvedValueOnce({
      data: { success: true, category: [{ _id: "3", name: "OldName" }] },
    });
    axios.put.mockResolvedValueOnce({ data: { success: true } });
    axios.get.mockResolvedValueOnce({
      data: { success: true, category: [{ _id: "3", name: "NewName" }] },
    });

    render(<CreateCategory />);

    await waitFor(() => screen.getByText("OldName"));

    fireEvent.click(screen.getByRole("button", { name: /Edit/i }));
    fireEvent.change(screen.getAllByPlaceholderText(/Enter new category/i)[1], {
      target: { value: "NewName" },
    });
    fireEvent.submit(screen.getAllByRole("button", { name: /Submit/i })[1]);

    await waitFor(() => {
      expect(axios.put).toHaveBeenCalledWith(expect.stringContaining("/api/v1/category/update-category/3"), { name: "NewName" });
      expect(screen.getByText("NewName")).toBeInTheDocument();
      expect(toast.success).toHaveBeenCalledWith("NewName is updated");
    });
  });

  test("hides modal on update", async () => {
    axios.get.mockResolvedValueOnce({
      data: { success: true, category: [{ _id: "3", name: "OldName" }] },
    });
    axios.put.mockResolvedValueOnce({ data: { success: true } });
    axios.get.mockResolvedValueOnce({
      data: { success: true, category: [{ _id: "3", name: "NewName" }] },
    });

    render(<CreateCategory />);

    await waitFor(() => screen.getByText("OldName"));

    fireEvent.click(screen.getByRole("button", { name: /Edit/i }));
    fireEvent.change(screen.getAllByPlaceholderText(/Enter new category/i)[1], {target: { value: "NewName" }});
    fireEvent.submit(screen.getAllByRole("button", { name: /Submit/i })[1]);

    await waitFor(() => {
      expect(screen.getByText("NewName")).toBeInTheDocument();
      expect(screen.getAllByPlaceholderText(/Enter new category/i)[1]).not.toBeVisible();
    });
  });

  test("handles category update POST error", async () => {
    axios.get.mockResolvedValueOnce({
      data: { success: true, category: [{ _id: "3", name: "OldName" }] },
    });
    axios.put.mockRejectedValueOnce(new Error("Network error"));

    render(<CreateCategory />);

    await waitFor(() => screen.getByText("OldName"));

    fireEvent.click(screen.getByRole("button", { name: /Edit/i }));
    fireEvent.change(screen.getAllByPlaceholderText(/Enter new category/i)[1], {
      target: { value: "NewName" },
    });
    fireEvent.submit(screen.getAllByRole("button", { name: /Submit/i })[1]);

    await waitFor(() =>
      expect(toast.error).toHaveBeenCalledWith("Something went wrong")
    );
  });

  test("handles category update unsuccessful response", async () => {
    const failureMessage = "Update failed";
    axios.get.mockResolvedValueOnce({
      data: { success: true, category: [{ _id: "3", name: "OldName" }] },
    });
    axios.put.mockResolvedValueOnce({ data: { success: false, message: failureMessage } });

    render(<CreateCategory />);

    await waitFor(() => screen.getByText("OldName"));

    fireEvent.click(screen.getByRole("button", { name: /Edit/i }));
    fireEvent.change(screen.getAllByPlaceholderText(/Enter new category/i)[1], {
      target: { value: "NewName" },
    });
    fireEvent.submit(screen.getAllByRole("button", { name: /Submit/i })[1]);

    await waitFor(() =>
      expect(toast.error).toHaveBeenCalledWith(failureMessage)
    );
  });


  test("deletes a category", async () => {
    axios.get.mockResolvedValueOnce({
      data: { success: true, category: [{ _id: "4", name: "ToDelete" }] },
    });
    axios.delete.mockResolvedValueOnce({ data: { success: true } });
    axios.get.mockResolvedValueOnce({ data: { success: true, category: [] } });

    render(<CreateCategory />);

    await waitFor(() => screen.getByText("ToDelete"));

    fireEvent.click(screen.getByRole("button", { name: /Delete/i }));

    await waitFor(() => {
      expect(axios.delete).toHaveBeenCalledWith(expect.stringContaining("/api/v1/category/delete-category/4"));
      expect(toast.success).toHaveBeenCalledWith("Category has been deleted");
    });
  });

  test("handles category delete POST error", async () => {
    axios.get.mockResolvedValueOnce({
      data: { success: true, category: [{ _id: "4", name: "ToDelete" }] },
    });
    axios.delete.mockRejectedValueOnce(new Error("Network error"));

    render(<CreateCategory />);

    await waitFor(() => screen.getByText("ToDelete"));

    fireEvent.click(screen.getByRole("button", { name: /Delete/i }));

    await waitFor(() =>
      expect(toast.error).toHaveBeenCalledWith("Something went wrong")
    );
  });

  test("handles category delete unsuccessful response", async () => {
    axios.get.mockResolvedValueOnce({
      data: { success: true, category: [{ _id: "4", name: "ToDelete" }] },
    });
    axios.delete.mockResolvedValueOnce({ data: { success: false, message: "Delete failed" } });
    axios.get.mockResolvedValueOnce({ data: { success: true, category: [] } });

    render(<CreateCategory />);

    await waitFor(() => screen.getByText("ToDelete"));

    fireEvent.click(screen.getByRole("button", { name: /Delete/i }));

    await waitFor(() =>
      expect(toast.error).toHaveBeenCalledWith("Delete failed")
    );
  });
});
