// This was initially generated by ChatGPT based on the original code and the following instruction:
// "help me write unit tests for this component:"
// There were edits to fix issues.
import React from "react";
import { render, screen, waitFor, fireEvent } from "@testing-library/react";
import UpdateProduct from "client/src/pages/admin/UpdateProduct";
import axios from "axios";
import toast from "react-hot-toast";
import userEvent from "@testing-library/user-event";
import { afterEach } from "node:test";

// mock dependencies
jest.mock("axios");
jest.mock("react-hot-toast", () => ({
  success: jest.fn(),
  error: jest.fn(),
}));

let mockNavigate = jest.fn();

jest.mock("react-router-dom", () => ({
  ...jest.requireActual("react-router-dom"),
  useNavigate: () => mockNavigate,
  useParams: () => ({ slug: "test-slug" }),
}));
jest.mock("client/src/components/Layout", () => ({ children }) => (
  <div>Mocked Layout {children}</div>
));
jest.mock("client/src/components/AdminMenu", () => () => <div>Mocked AdminMenu</div>);

describe("UpdateProduct Component", () => {
  let defaultProduct;
  beforeEach(() => {
    jest.resetAllMocks();
    window.URL.createObjectURL = jest.fn(() => "mocked-url");
    mockNavigate = jest.fn();
    defaultProduct = {
      _id: "123",
      name: "Test Product",
      description: "Test Description",
      price: 100,
      quantity: 5,
      shipping: 1,
      category: { _id: "cat1" },
    };
  });

  test("renders basic layout", async () => {
    axios.get
        .mockResolvedValueOnce({
            data: {
                product: defaultProduct,
            },
        })
        .mockResolvedValueOnce({
            data: { success: true, category: [{ _id: "cat1", name: "Category 1" }] },
        });
    
    render(<UpdateProduct />);
    await waitFor(() => {
        expect(screen.getByText("Update Product")).toBeInTheDocument();
        expect(screen.getByText("UPDATE PRODUCT")).toBeInTheDocument();
        expect(screen.getByText(/delete product/i)).toBeInTheDocument();
        expect(screen.getByText(/Mocked Layout/i)).toBeInTheDocument();
        expect(screen.getByText(/Mocked AdminMenu/i)).toBeInTheDocument();
    });
  });

  test("redirects invalid slug without crashing", async () => {
    axios.get
        .mockResolvedValueOnce(null) // Simulate product not found
        .mockResolvedValueOnce({
            data: { success: true, category: [{ _id: "cat1", name: "Category 1" }] },
        });
    render(<UpdateProduct />);
    await waitFor(() => {
        expect(toast.error).toHaveBeenCalledWith("Product not found");
        expect(mockNavigate).toHaveBeenCalledWith("/dashboard/admin/products");
    });
  });

  test("loads single product and category on mount", async () => {
    axios.get
      .mockResolvedValueOnce({
          data: {
              product: { ...defaultProduct, photo: "photo-url"},
          },
      })
      .mockResolvedValueOnce({
          data: { success: true, category: [{ _id: "cat1", name: "Category 1" }] },
      });

    render(<UpdateProduct />);


    await waitFor(() => {
      expect(axios.get).toHaveBeenCalledWith("/api/v1/product/get-product/test-slug");
      expect(screen.getByDisplayValue("Test Product")).toBeInTheDocument();
      expect(screen.getByDisplayValue("Test Description")).toBeInTheDocument();
      expect(screen.getByDisplayValue("100")).toBeInTheDocument();
      expect(screen.getByDisplayValue("5")).toBeInTheDocument();
      expect(screen.getByText("Category 1")).toBeInTheDocument();
      expect(screen.getByText(/yes/i)).toBeInTheDocument();
      expect(screen.getByAltText("product_photo")).toBeInTheDocument();
      expect(URL.createObjectURL).toHaveBeenCalledWith("photo-url");
    });
  });

  test("shows error toast if loading categories API fails", async () => {
    axios.get
      .mockResolvedValueOnce({
          data: {
              product: defaultProduct,
          },
      })
      .mockRejectedValueOnce(new Error("Network error"));

    render(<UpdateProduct />);

    await waitFor(() => {
      expect(toast.error).toHaveBeenCalledWith("Something went wrong in getting categories");
    });
  });

  test("shows error toast if loading categories result unsuccessful", async () => {
    axios.get
      .mockResolvedValueOnce({
          data: {
              product: defaultProduct,
          },
      })
      .mockResolvedValueOnce({
          data: { success: false, message: "Failed to load" },
      });

    render(<UpdateProduct />);

    await waitFor(() => {
      expect(toast.error).toHaveBeenCalledWith("Failed to load");
    });
  });

  test("displays new category when selected", async () => {
    axios.get
      .mockResolvedValueOnce({
          data: {
              product: defaultProduct,
          },
      })
      .mockResolvedValueOnce({
          data: { success: true, category: [{ _id: "cat1", name: "Category 1" }, { _id: "cat2", name: "Category 2" }] },
      });
      
    render(<UpdateProduct />);

    await waitFor(() => {
      expect(screen.getByText("Category 1")).toBeInTheDocument();
    });

    fireEvent.mouseDown(screen.getByText('Category 1'));
    await waitFor(() => screen.getByText("Category 2"));
    fireEvent.click(screen.getByText("Category 2"));

    expect(screen.getAllByText("Category 2")).toHaveLength(2); // once in dropdown, once as selected
  });

  test("displays default image preview", async () => {
    axios.get
      .mockResolvedValueOnce({
          data: {
              product: defaultProduct,
          },
      })
      .mockResolvedValueOnce({
          data: { success: true, category: [{ _id: "cat1", name: "Category 1" }] },
      });

    render(<UpdateProduct />);

    await waitFor(() => {
      expect(URL.createObjectURL).not.toHaveBeenCalled();
      expect(screen.getByAltText("product_photo")).toBeInTheDocument();
    });
  });

  test("updates product successfully", async () => {
    // mock product load
    axios.get.mockResolvedValueOnce({
      data: {
        product: { ...defaultProduct},
      },
    });
    axios.get.mockResolvedValueOnce({
      data: { success: true, category: [{ _id: "cat1", name: "Category 1" }, { _id: "cat2", name: "Category 2" }] },
    });

    // mock update API
    axios.put.mockResolvedValueOnce({ data: { success: true } });

    render(<UpdateProduct />);

    // wait for data to load
    await waitFor(() =>
      expect(screen.getByDisplayValue("Test Product")).toBeInTheDocument()
    );

    fireEvent.change(screen.getByDisplayValue("Test Product"), {
      target: { value: "Changed Name" },
    });
    fireEvent.change(screen.getByDisplayValue("Test Description"), {
      target: { value: "Changed Description" },
    });
    fireEvent.change(screen.getByDisplayValue("100"), {
      target: { value: "150" },
    });
    fireEvent.change(screen.getByDisplayValue("5"), {
      target: { value: "10" },
    });
    fireEvent.mouseDown(screen.getByText('Category 1'));
    await waitFor(() => screen.getByText("Category 2"));
    fireEvent.click(screen.getByText("Category 2"));

    fireEvent.mouseDown(screen.getByText("Yes"));
    await waitFor(() => screen.getByText("No"));
    fireEvent.click(screen.getByText("No"));

    const input = screen.getByLabelText(/upload photo/i, { selector: "input" });
    const file = new File(["hello"], "test.png", { type: "image/png" });
    await waitFor(() => userEvent.upload(input, file));

    await waitFor(() => {
      expect(screen.getByDisplayValue("Changed Name")).toBeInTheDocument();
      expect(screen.getByDisplayValue("Changed Description")).toBeInTheDocument();
      expect(screen.getByDisplayValue("150")).toBeInTheDocument();
      expect(screen.getByDisplayValue("10")).toBeInTheDocument();
      expect(screen.getAllByText("Category 2")).toHaveLength(2);
      expect(screen.getByText("No")).toBeInTheDocument();
      expect(screen.getByLabelText("test.png")).toBeInTheDocument();
    });

    fireEvent.click(screen.getByText("UPDATE PRODUCT"));

    await waitFor(() => {
      expect(axios.put).toHaveBeenCalledWith("/api/v1/product/update-product/123", expect.any(FormData));
      const [[, formDataArg]] = axios.put.mock.calls;
      expect(formDataArg.get("name")).toBe("Changed Name");
      expect(formDataArg.get("description")).toBe("Changed Description");
      expect(formDataArg.get("price")).toBe("150");
      expect(formDataArg.get("quantity")).toBe("10");
      expect(formDataArg.get("category")).toBe("cat2");
      expect(formDataArg.get("shipping")).toBe("0");
      expect(formDataArg.get("photo")).toBe(file);
      expect(toast.success).toHaveBeenCalledWith("Product Updated Successfully");
      expect(mockNavigate).toHaveBeenCalledWith("/dashboard/admin/products");
    });
  });

  test("update product shows error toast if API failed", async () => {
    axios.get.mockResolvedValueOnce({
      data: {
        product: defaultProduct,
      },
    });
    axios.get.mockResolvedValueOnce({
      data: { success: true, category: [{ _id: "cat1", name: "Category 1" }] },
    });

    // mock failure
    axios.put.mockRejectedValueOnce(new Error("Network error"));

    render(<UpdateProduct />);

    await waitFor(() =>
      expect(screen.getByDisplayValue("Test Product")).toBeInTheDocument()
    );

    fireEvent.click(screen.getByText("UPDATE PRODUCT"));

    await waitFor(() =>
      expect(toast.error).toHaveBeenCalledWith("Something went wrong")
    );
  });

  test("update product shows error toast if result is unsuccessful", async () => {
    axios.get.mockResolvedValueOnce({
      data: {
        product: defaultProduct,
      },
    });
    axios.get.mockResolvedValueOnce({
      data: { success: true, category: [] },
    });

    // mock failure
    axios.put.mockResolvedValueOnce({ data: { success: false, message: "Update_failed" } });

    render(<UpdateProduct />);

    await waitFor(() =>
      expect(screen.getByDisplayValue("Test Product")).toBeInTheDocument()
    );

    fireEvent.click(screen.getByText("UPDATE PRODUCT"));

    await waitFor(() =>
      expect(toast.error).toHaveBeenCalledWith("Update_failed")
    );
  });

  test("deletes product after confirm", async () => {
    axios.get.mockResolvedValueOnce({
      data: {
        product: {
          _id: "123",
          name: "DeleteMe",
          description: "To be deleted",
          price: 20,
          quantity: 1,
          shipping: 1,
          category: { _id: "cat1" },
        },
      },
    });
    axios.get.mockResolvedValueOnce({
      data: { success: true, category: [] },
    });

    axios.delete.mockResolvedValueOnce({ data: { success: true } });

    // mock confirm
    window.confirm = jest.fn(() => true);

    render(<UpdateProduct />);

    await waitFor(() =>
      expect(screen.getByDisplayValue("DeleteMe")).toBeInTheDocument()
    );

    fireEvent.click(screen.getByText(/delete product/i));


    await waitFor(() => {
      expect(axios.delete).toHaveBeenCalledWith("/api/v1/product/delete-product/123");
      expect(toast.success).toHaveBeenCalledWith("Product Deleted Successfully");
      expect(mockNavigate).toHaveBeenCalledWith("/dashboard/admin/products");
    });
  });

  test("does not delete product if not confirmed", async () => {
    axios.get.mockResolvedValueOnce({
      data: {
        product: {
          _id: "123",
          name: "DontDeleteMe",
          description: "Should stay",
          price: 20,
          quantity: 1,
          shipping: 1,
          category: { _id: "cat1" },
        },
      },
    });
    axios.get.mockResolvedValueOnce({
      data: { success: true, category: [] },
    });

    // mock confirm to cancel
    window.confirm = jest.fn(() => false);

    render(<UpdateProduct />);

    await waitFor(() =>
      expect(screen.getByDisplayValue("DontDeleteMe")).toBeInTheDocument()
    );

    fireEvent.click(screen.getByText(/delete product/i));

    await waitFor(() => {
      expect(axios.delete).not.toHaveBeenCalled();
      expect(toast.success).not.toHaveBeenCalled();
      expect(mockNavigate).not.toHaveBeenCalled();
    });
  });

  test("delete product shows error toast if API fails", async () => {
    axios.get.mockResolvedValueOnce({
      data: {
        product: {
          _id: "123",
          name: "DeleteMe",
          description: "To be deleted",
          price: 20,
          quantity: 1,
          shipping: 1,
          category: { _id: "cat1" },
        },
      },
    });
    axios.get.mockResolvedValueOnce({
      data: { success: true, category: [] },
    });

    // mock failure
    axios.delete.mockRejectedValueOnce(new Error("Network error"));

    // mock confirm
    window.confirm = jest.fn(() => true);

    render(<UpdateProduct />);

    await waitFor(() =>
      expect(screen.getByDisplayValue("DeleteMe")).toBeInTheDocument()
    );

    fireEvent.click(screen.getByText(/delete product/i));

    await waitFor(() =>
      expect(toast.error).toHaveBeenCalledWith("Something went wrong")
    );
  });
});
