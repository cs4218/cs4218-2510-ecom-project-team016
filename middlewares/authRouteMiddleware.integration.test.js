// This was initially generated by ChatGPT based on the original codes and the following instruction:
// "Help me write integration test the middleware functions in the auth routes"
// There were edits to fix issues.
import express from "express";
import request from "supertest";
import JWT from "jsonwebtoken";
import authRouter from "../routes/authRoute.js";
import userModel from "../models/userModel.js";
import { describe } from "node:test";
import orderModel from "../models/orderModel.js";

// Mock the models
jest.mock("../models/userModel.js");
jest.mock("../models/orderModel.js");

// Mock the auth helper
jest.mock("../helpers/authHelper.js", () => ({
  hashPassword: jest.fn((password) => `hashed_${password}`),
  comparePassword: jest.fn(
    (password, hashedPassword) => hashedPassword === `hashed_${password}`
  ),
}));

describe("Auth Route → Middleware → Controller Integration Tests", () => {
  let app;
  const TEST_JWT_SECRET = "test-secret-key";
  const ORIGINAL_JWT_SECRET = process.env.JWT_SECRET;

  beforeAll(() => {
    // Set test JWT secret
    process.env.JWT_SECRET = TEST_JWT_SECRET;

    // Create Express app with the auth routes
    app = express();
    app.use(express.json());
    app.use("/api/v1/auth", authRouter);
  });

  afterAll(() => {
    // Restore original JWT secret
    process.env.JWT_SECRET = ORIGINAL_JWT_SECRET;
  });

  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe("Test requiredSignIn middleware with test /user-auth controller", () => {
    test("Valid JWT token passes through requireSignIn and reaches controller", async () => {
      const mockUser = {
        _id: "user123",
        name: "Test User",
        email: "test@example.com",
        role: 0,
      };

      const validToken = JWT.sign({ _id: mockUser._id }, TEST_JWT_SECRET, {
        expiresIn: "7d",
      });

      const response = await request(app)
        .get("/api/v1/auth/user-auth")
        .set("Authorization", validToken);

      expect(response.status).toBe(200);
      expect(response.body).toEqual({ ok: true });
    });

    test("Invalid JWT token is rejected by requireSignIn", async () => {
      const invalidToken = "invalid.jwt.token";

      const response = await request(app)
        .get("/api/v1/auth/user-auth")
        .set("Authorization", invalidToken);

      expect(response.status).toBe(500);
      expect(response.body.success).toBe(false);
      expect(response.body.message).toBe("Error in requireSignIn middleware");
    });

    test("Expired JWT token is rejected by requireSignIn", async () => {
      const expiredToken = JWT.sign(
        { _id: "user123" },
        TEST_JWT_SECRET,
        { expiresIn: "-1s" } // Already expired
      );

      const response = await request(app)
        .get("/api/v1/auth/user-auth")
        .set("Authorization", expiredToken);

      expect(response.status).toBe(500);
      expect(response.body.success).toBe(false);
      expect(response.body.message).toBe("Error in requireSignIn middleware");
    });

    test("Missing authorization header is handled properly", async () => {
      const response = await request(app).get("/api/v1/auth/user-auth");

      expect(response.status).toBe(500);
      expect(response.body.success).toBe(false);
      expect(response.body.message).toBe("Error in requireSignIn middleware");
    });

    test("Token signed with wrong secret is rejected", async () => {
      const wrongSecretToken = JWT.sign(
        { _id: "user123" },
        "wrong-secret-key",
        { expiresIn: "7d" }
      );

      const response = await request(app)
        .get("/api/v1/auth/user-auth")
        .set("Authorization", wrongSecretToken);

      expect(response.status).toBe(500);
      expect(response.body.success).toBe(false);
      expect(response.body.message).toBe("Error in requireSignIn middleware");
    });
  });

  describe("Test requireSignIn middleware with updateProfileController", () => {
    test("req.user is correctly populated by middleware for use in controller", async () => {
      const mockUser = {
        _id: "user123",
        name: "Test User",
        email: "test@example.com",
        phone: "1234567890",
        address: "123 Test St",
        role: 0,
        password: "hashed_oldpassword",
      };

      const validToken = JWT.sign({ _id: mockUser._id }, TEST_JWT_SECRET, {
        expiresIn: "7d",
      });

      userModel.findById.mockResolvedValue(mockUser);

      const updatedUser = {
        ...mockUser,
        name: "Updated Name",
        phone: "9876543210",
      };
      userModel.findByIdAndUpdate.mockResolvedValue(updatedUser);

      // Act: Make request to update profile
      const response = await request(app)
        .put("/api/v1/auth/profile")
        .set("Authorization", validToken)
        .send({
          name: "Updated Name",
          phone: "9876543210",
        });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.message).toBe("Profile Updated Successfully");
      expect(response.body.updatedUser.name).toBe("Updated Name");
      expect(response.body.updatedUser.phone).toBe("9876543210");

      expect(userModel.findById).toHaveBeenCalledWith(mockUser._id);
      expect(userModel.findByIdAndUpdate).toHaveBeenCalledWith(
        mockUser._id,
        expect.any(Object),
        { new: true }
      );
    });

    test("Invalid token prevents profile update", async () => {
      const invalidToken = "invalid.token";

      const response = await request(app)
        .put("/api/v1/auth/profile")
        .set("Authorization", invalidToken)
        .send({
          name: "Updated Name",
        });

      expect(response.status).toBe(500);
      expect(response.body.success).toBe(false);
      expect(response.body.message).toBe("Error in requireSignIn middleware");

      expect(userModel.findById).not.toHaveBeenCalled();
      expect(userModel.findByIdAndUpdate).not.toHaveBeenCalled();
    });
  });

  describe("Test requireSignIn middleware with getOrdersController", () => {
    test("returns order when user._id is valid", async () => {
      const mockUser = {
        _id: "user123",
        name: "Test User",
        email: "test@example.com",
        phone: "1234567890",
        address: "123 Test St",
        role: 0,
        password: "hashed_oldpassword",
      };

      const validToken = JWT.sign(mockUser, TEST_JWT_SECRET, {
        expiresIn: "7d",
      });

      const mockOrders = [
        {
          _id: "order1",
          buyer: mockUser._id,
          products: [],
          status: "Processing",
        },
        {
          _id: "order2",
          buyer: mockUser._id,
          products: [],
          status: "Delivered",
        },
      ];

      const mockPopulate = jest.fn().mockReturnThis();
      orderModel.find = jest.fn().mockImplementation(({ buyer }) => {
        if (buyer == null || buyer == undefined) {
          return null;
        }

        if (buyer != mockUser._id) {
          return null;
        }

        return {
          populate: mockPopulate.mockReturnValue({
            populate: jest.fn().mockResolvedValue(mockOrders),
          }),
        };
      });

      // Act: Make request to update profile
      const response = await request(app)
        .get("/api/v1/auth/orders")
        .set("Authorization", validToken);

      expect(response.status).toBe(200);
      expect(Array.isArray(response.body)).toBe(true);
      expect(response.body).toEqual(mockOrders);
    });
  });

  describe("Test requireSignIn middleware with getAllOrdersController", () => {
    test("Admin user as token gets access to getAllOrderController", async () => {
      const mockUser = {
        _id: "user123",
        name: "Test User",
        email: "test@example.com",
        phone: "1234567890",
        address: "123 Test St",
        role: 1,
        password: "hashed_oldpassword",
      };

      const validToken = JWT.sign(mockUser, TEST_JWT_SECRET, {
        expiresIn: "7d",
      });

      userModel.findById.mockImplementation((id) => {
        if (id != mockUser._id) {
          return null;
        }

        return mockUser;
      });

      const mockOrders = [
        {
          _id: "order1",
          buyer: mockUser._id,
          products: [],
          status: "Processing",
        },
        {
          _id: "order2",
          buyer: mockUser._id,
          products: [],
          status: "Delivered",
        },
      ];

      const mockPopulate = jest.fn().mockReturnThis();
      orderModel.find = jest.fn().mockReturnValue({
        populate: jest.fn().mockReturnValue({
          populate: jest.fn().mockReturnValue({
            sort: jest.fn().mockResolvedValue(mockOrders),
          }),
        }),
      });

      const response = await request(app)
        .get("/api/v1/auth/all-orders")
        .set("Authorization", validToken);

      expect(response.status).toBe(200);
      expect(Array.isArray(response.body)).toBe(true);
      expect(response.body).toEqual(mockOrders);
    });

    test("Non admin user as token does not get access to getAllOrderController", async () => {
      const mockUser = {
        _id: "user123",
        name: "Test User",
        email: "test@example.com",
        phone: "1234567890",
        address: "123 Test St",
        role: 0,
        password: "hashed_oldpassword",
      };

      const validToken = JWT.sign(mockUser, TEST_JWT_SECRET, {
        expiresIn: "7d",
      });

      userModel.findById.mockImplementation((id) => {
        if (id != mockUser._id) {
          return null;
        }

        return mockUser;
      });

      const response = await request(app)
        .get("/api/v1/auth/all-orders")
        .set("Authorization", validToken);

      expect(response.status).toBe(401);
      expect(response.body.success).toBe(false);
      expect(response.body.message).toBe("UnAuthorized Access");
    });

    test("Missing token prevents access to orders", async () => {
      const response = await request(app).get("/api/v1/auth/all-orders");

      expect(response.status).toBe(500);
      expect(response.body.success).toBe(false);
      expect(response.body.message).toBe("Error in requireSignIn middleware");
    });
  });

  describe("Test admin protected routes", () => {
    test("Admin user passes through both middlewares to controller", async () => {
      const mockAdminUser = {
        _id: "admin123",
        name: "Admin User",
        email: "admin@example.com",
        role: 1,
      };

      const validToken = JWT.sign({ _id: mockAdminUser._id }, TEST_JWT_SECRET, {
        expiresIn: "7d",
      });

      userModel.findById.mockResolvedValue(mockAdminUser);

      const response = await request(app)
        .get("/api/v1/auth/test")
        .set("Authorization", validToken);

      expect(response.status).toBe(200);
      expect(response.text).toBe("Protected Routes");

      expect(userModel.findById).toHaveBeenCalledWith(mockAdminUser._id);
    });

    test("Regular user is blocked by isAdmin middleware", async () => {
      const mockRegularUser = {
        _id: "user123",
        name: "Regular User",
        email: "user@example.com",
        role: 0,
      };

      const validToken = JWT.sign(
        { _id: mockRegularUser._id },
        TEST_JWT_SECRET,
        { expiresIn: "7d" }
      );

      userModel.findById.mockResolvedValue(mockRegularUser);

      const response = await request(app)
        .get("/api/v1/auth/test")
        .set("Authorization", validToken);

      expect(response.status).toBe(401);
      expect(response.body.success).toBe(false);
      expect(response.body.message).toBe("UnAuthorized Access");

      expect(userModel.findById).toHaveBeenCalledWith(mockRegularUser._id);
    });

    test("Invalid token is rejected by requireSignIn before reaching isAdmin", async () => {
      const invalidToken = "invalid.token";

      const response = await request(app)
        .get("/api/v1/auth/test")
        .set("Authorization", invalidToken);

      expect(response.status).toBe(500);
      expect(response.body.message).toBe("Error in requireSignIn middleware");

      expect(userModel.findById).not.toHaveBeenCalled();
    });

    test("User not found in database is handled by isAdmin middleware", async () => {
      const validToken = JWT.sign({ _id: "nonexistent123" }, TEST_JWT_SECRET, {
        expiresIn: "7d",
      });

      userModel.findById.mockResolvedValue(null);

      const response = await request(app)
        .get("/api/v1/auth/test")
        .set("Authorization", validToken);

      expect(response.status).toBe(404);
      expect(response.body.success).toBe(false);
      expect(response.body.message).toBe("User not found");

      expect(userModel.findById).toHaveBeenCalledWith("nonexistent123");
    });
  });

  describe("Integration test of requireSignIn with /admin-auth", () => {
    test("Complete middleware chain validation for admin route", async () => {
      const mockAdminUser = {
        _id: "admin456",
        name: "Super Admin",
        email: "superadmin@example.com",
        role: 1,
      };

      const validToken = JWT.sign({ _id: mockAdminUser._id }, TEST_JWT_SECRET, {
        expiresIn: "7d",
      });

      userModel.findById.mockResolvedValue(mockAdminUser);

      const response = await request(app)
        .get("/api/v1/auth/admin-auth")
        .set("Authorization", validToken);

      expect(response.status).toBe(200);
      expect(response.body).toEqual({ ok: true });

      expect(userModel.findById).toHaveBeenCalledWith(mockAdminUser._id);
    });
  });
});
